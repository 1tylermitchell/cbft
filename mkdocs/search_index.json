{
    "docs": [
        {
            "location": "/", 
            "text": "What is cbft\n\n\ncbft, or Couchbase Full-Text server, is distributed, clusterable, data\nindexing server.\n\n\nIt includes the ability to manage full-text and other kinds of indexes\nfor JSON documents that you've created and stored into a Couchbase\nbucket and other data sources.\n\n\nThe indexes that cbft manages can be automatically distributed across\nmultiple, clustered cbft server processes on different server machines\nto support larger indexes, higher performance and higher availability.\n\n\nDeveloper preview\n\n\ncbft is still in its infancy and under active development, and is\ncurrently available as a \"developer preview\" level of quality.\n\n\nAny feedback provided at this early stage by the early users and the\ncommunity are greatly appreciated by the development team.\n\n\nNow's a great time to affect cbft's features and its directions with\nyour input!\n\n\nAs a developer preview, some disclaimers and limitations...\n\n\n\n\n\n\nquality level - cbft is not yet production ready quality.\n\n\n\n\n\n\ncbft has not been performance optimized.\n\n\n\n\n\n\ncbft's API's are still subject to large, potentially\n  backwards-incompatible changes.\n\n\n\n\n\n\ncbft's file storage backends are still subject to change.\n\n\n\n\n\n\npartial index rollbacks are not yet supported by cbft developer\n  preview.\n\n\n\n\n\n\ncbft does not handle the bucket FLUSH command properly yet.  If you\n  get into a stuck cbft index due to a bucket FLUSH operation, your\n  best recourse is to delete and recreate your index.\n  https://github.com/couchbaselabs/cbft/issues/28\n\n\n\n\n\n\nGetting started\n\n\nPrerequisites\n\n\nYou should have a Couchbase Server (3.x, 4.x or greater) already\ninstalled and running before trying the rest of these getting started\nsteps.\n\n\nIf you're not already running Couchbase Server and need to download\nit, please see...\n\n\n\n\nhttp://www.couchbase.com/downloads\n\n\n\n\nYou should also have a bucket in Couchbase Server with JSON documents\nthat you'd like to index.\n\n\nFor example, while during the setup steps of Couchbase Server, you can\nhave Couchbase Server create and populate a \nbeer-sample\n bucket\nof sample JSON documents.\n\n\nGetting cbft\n\n\nDownload a pre-built cbft from the\n\nreleases\n page...\n\n\n\n\nhttps://github.com/couchbaselabs/cbft/releases\n\n\n\n\nYou can use your favorite web browser to download.\n\n\nOr, you can use \nwget\n or equivalent command-line tool.\n\n\nFor example, for mac OS...\n\n\nwget https://github.com/couchbaselabs/cbft/releases/download/v{X.Y.Z}/cbft-v{X.Y.Z-AAA}.macos.amd64.tar.gz\n\n\n\nNote: some platforms support both \ncbft-full\n and \ncbft\n\nbuilds.\n\n\n\n\n\n\nThe \ncbft-full\n builds are currently compiled with some\n  platform-specific advanced features (text stemmers, etc).\n\n\n\n\n\n\nThe \ncbft\n basic builds are exactly the same across all\n  platforms, for deployment consistency.\n\n\n\n\n\n\nFor the purposes of these getting started steps, let's just download\n\ncbft\n basic builds.\n\n\nAfter downloading, then next uncompress what you downloaded...\n\n\ntar -xzf cbft-v{X.Y.Z-AAA}.macos.amd64.tar.gz\n\n\n\nOn windows, for example, you would use unzip...\n\n\nunzip cbft-v{X.Y.Z-AAA}.windows.amd64.exe.zip\n\n\n\nA quick way to make sure it worked is to try the command-line help...\n\n\n./cbft.macos.amd64 --help\n\n\n\nOn windows, for example, you would use...\n\n\ncbft.windows.amd64.exe --help\n\n\n\nFor the rest of this documentation, we'll just refer to the cbft\nexecutable as \n./cbft\n rather than some platform specific name\nlike \n./cbft.macos.amd64\n.\n\n\nRunning cbft\n\n\nStart cbft, pointing it to your Couchbase Server as your default\ndatasource server...\n\n\n./cbft -server http://localhost:8091\n\n\n\nOn windows, for example...\n\n\ncbft -server http://localhost:8091\n\n\n\nNote: cbft also defaults to using a directory named \"data\" as its data\ndirectory, which cbft will create in the current working directory if\nit does not exist yet.  You can change the data directory path by\nusing the \n-dataDir\n command-line parameter.\n\n\nThe web admin UI\n\n\nNext, point your web browser to cbft's web admin UI...\n\n\nhttp://localhost:8095\n\n\n\nIn your web browser, you should see a \"Welcome to cbft\" page in the\nweb admin UI.\n\n\nThat welcome page will list all the indexes that you've defined; of\ncourse, there should be no indexes at this point.\n\n\nCreating a full-text index\n\n\nNext, let's create your first full-text index in cbft.\n\n\nOn the Indexes listing page (the \"Welcome to cbft\" page), click on the\n\nNew Index\n button.\n\n\nA form should appear where you can define your new index\nconfiguration.\n\n\nNext, let's fill in the form fields...\n\n\nIndex Name\n\n\nEach index needs a unique name.\n\n\nIn the Index Name field, type in a name, such as \"test-index\".\n\n\nOnly alphanumeric characters, hyphens and underscores are allowed for\nindex names.  Also, the first character must be a alphabetic\ncharacter.\n\n\nIndex Type\n\n\nThe Index Type specifies what kind of index that cbft will create.\n\n\nFrom the Index Type dropdown, choose \nfull-text (bleve)\n.\n\n\nAs soon as you make an Index Type dropdown selection, some additional,\ntype-dependent input fields should appear (such as an Index Mapping),\nbut let's ignore them for now and use the provided defaults.\n\n\nSource Type\n\n\nThe Source Type specifies what kind of datasource will be used for the\nindex.\n\n\nFrom the Source Type dropdown, choose \ncouchbase\n.\n\n\nAs soon as you make a Source Type dropdown selection, some additional\ntype-dependent input fields (such as Source Name) should\nappear.\n\n\nSource Name\n\n\nSince our Source Type is \ncouchbase\n, the Source Name should be\nname of a bucket.\n\n\nNext, type in your bucket's name into the Source Name field.\n\n\nFor example, to index the \"default\" bucket from your Couchbase\nserver, type in a Source Name of \"default\".\n\n\nNOTE: if your bucket has a password, you can supply the password by\nclicking on the \nShow advanced settings\n checkbox, which will\ndisplay the \nSource Params\n JSON textarea.  Then, fill in the\n\nauthUser\n field in the JSON with the name of the Couchbase bucket\nand the \nauthPassword\n field with the bucket's password.\n\n\nYour new index\n\n\nFinally, click the \nCreate Index\n button.\n\n\nYou should see a summary page of your new full-text index.\n\n\nThe \nDocument Count\n field on the index summary page is a snapshot\nof how many documents have been indexed so far.  You can click on the\n\nRefresh\n button next to the Document Count in order to see\nindexing progress.\n\n\nQuerying your full-text index\n\n\nNext, click on the \nQuery\n tab.\n\n\nIn the query field, type in a query term.\n\n\nHit enter/return to execute your first cbft full-text query!\n\n\nYou should see query results appearing below the query field.\n\n\nUsing the REST API\n\n\nYou can also use the REST API to access your index.\n\n\nFor example, if your index is named \nmyFirstIndex\n, here's how you\ncan use the curl tool to check how many documents are indexed...\n\n\ncurl http://localhost:8095/api/index/myFirstIndex/count\n\n\n\nHere's an example of using curl to query the \nmyFirstIndex\n...\n\n\ncurl -XPOST --header Content-Type:text/json \\\n     -d '{\"size\":10,\"query\":{\"query\":\"your search string\"}}' \\\n     http://localhost:8095/api/index/myFirstIndex/query\n\n\n\nWhere to go next\n\n\nThat's about it for getting started.\n\n\nYou can see the other command-line parameters of cbft with the\n\n-h\n flag...\n\n\n./cbft -h\n\n\n\nAdditionally, cbft's web admin UI has more screens and features, so be\nsure to click around and explore!\n\n\nFinally, don't forget to take a look at these additional documents...\n\n\n\n\nDeveloper's guide\n\n\nAPI reference\n\n\nAdministrator's guide\n\n\nLinks to more resources\n\n\n\n\nProviding your feedback\n\n\nIf you need help, would like to contribute feedback, or would like to\ntalk about the cbft with like-minded folks, please have a look at the\n\nCouchbase forums\n and the links to\n\nmore resources\n.\n\n\nTo report bugs or feature requests, please use the cbft issue tracker\ncurrently hosted at\n\ngithub\n.\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Home"
        }, 
        {
            "location": "/#what-is-cbft", 
            "text": "cbft, or Couchbase Full-Text server, is distributed, clusterable, data\nindexing server.  It includes the ability to manage full-text and other kinds of indexes\nfor JSON documents that you've created and stored into a Couchbase\nbucket and other data sources.  The indexes that cbft manages can be automatically distributed across\nmultiple, clustered cbft server processes on different server machines\nto support larger indexes, higher performance and higher availability.", 
            "title": "What is cbft"
        }, 
        {
            "location": "/#developer-preview", 
            "text": "cbft is still in its infancy and under active development, and is\ncurrently available as a \"developer preview\" level of quality.  Any feedback provided at this early stage by the early users and the\ncommunity are greatly appreciated by the development team.  Now's a great time to affect cbft's features and its directions with\nyour input!  As a developer preview, some disclaimers and limitations...    quality level - cbft is not yet production ready quality.    cbft has not been performance optimized.    cbft's API's are still subject to large, potentially\n  backwards-incompatible changes.    cbft's file storage backends are still subject to change.    partial index rollbacks are not yet supported by cbft developer\n  preview.    cbft does not handle the bucket FLUSH command properly yet.  If you\n  get into a stuck cbft index due to a bucket FLUSH operation, your\n  best recourse is to delete and recreate your index.\n  https://github.com/couchbaselabs/cbft/issues/28", 
            "title": "Developer preview"
        }, 
        {
            "location": "/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/#prerequisites", 
            "text": "You should have a Couchbase Server (3.x, 4.x or greater) already\ninstalled and running before trying the rest of these getting started\nsteps.  If you're not already running Couchbase Server and need to download\nit, please see...   http://www.couchbase.com/downloads   You should also have a bucket in Couchbase Server with JSON documents\nthat you'd like to index.  For example, while during the setup steps of Couchbase Server, you can\nhave Couchbase Server create and populate a  beer-sample  bucket\nof sample JSON documents.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/#getting-cbft", 
            "text": "Download a pre-built cbft from the releases  page...   https://github.com/couchbaselabs/cbft/releases   You can use your favorite web browser to download.  Or, you can use  wget  or equivalent command-line tool.  For example, for mac OS...  wget https://github.com/couchbaselabs/cbft/releases/download/v{X.Y.Z}/cbft-v{X.Y.Z-AAA}.macos.amd64.tar.gz  Note: some platforms support both  cbft-full  and  cbft \nbuilds.    The  cbft-full  builds are currently compiled with some\n  platform-specific advanced features (text stemmers, etc).    The  cbft  basic builds are exactly the same across all\n  platforms, for deployment consistency.    For the purposes of these getting started steps, let's just download cbft  basic builds.  After downloading, then next uncompress what you downloaded...  tar -xzf cbft-v{X.Y.Z-AAA}.macos.amd64.tar.gz  On windows, for example, you would use unzip...  unzip cbft-v{X.Y.Z-AAA}.windows.amd64.exe.zip  A quick way to make sure it worked is to try the command-line help...  ./cbft.macos.amd64 --help  On windows, for example, you would use...  cbft.windows.amd64.exe --help  For the rest of this documentation, we'll just refer to the cbft\nexecutable as  ./cbft  rather than some platform specific name\nlike  ./cbft.macos.amd64 .", 
            "title": "Getting cbft"
        }, 
        {
            "location": "/#running-cbft", 
            "text": "Start cbft, pointing it to your Couchbase Server as your default\ndatasource server...  ./cbft -server http://localhost:8091  On windows, for example...  cbft -server http://localhost:8091  Note: cbft also defaults to using a directory named \"data\" as its data\ndirectory, which cbft will create in the current working directory if\nit does not exist yet.  You can change the data directory path by\nusing the  -dataDir  command-line parameter.", 
            "title": "Running cbft"
        }, 
        {
            "location": "/#the-web-admin-ui", 
            "text": "Next, point your web browser to cbft's web admin UI...  http://localhost:8095  In your web browser, you should see a \"Welcome to cbft\" page in the\nweb admin UI.  That welcome page will list all the indexes that you've defined; of\ncourse, there should be no indexes at this point.", 
            "title": "The web admin UI"
        }, 
        {
            "location": "/#creating-a-full-text-index", 
            "text": "Next, let's create your first full-text index in cbft.  On the Indexes listing page (the \"Welcome to cbft\" page), click on the New Index  button.  A form should appear where you can define your new index\nconfiguration.  Next, let's fill in the form fields...  Index Name  Each index needs a unique name.  In the Index Name field, type in a name, such as \"test-index\".  Only alphanumeric characters, hyphens and underscores are allowed for\nindex names.  Also, the first character must be a alphabetic\ncharacter.  Index Type  The Index Type specifies what kind of index that cbft will create.  From the Index Type dropdown, choose  full-text (bleve) .  As soon as you make an Index Type dropdown selection, some additional,\ntype-dependent input fields should appear (such as an Index Mapping),\nbut let's ignore them for now and use the provided defaults.  Source Type  The Source Type specifies what kind of datasource will be used for the\nindex.  From the Source Type dropdown, choose  couchbase .  As soon as you make a Source Type dropdown selection, some additional\ntype-dependent input fields (such as Source Name) should\nappear.  Source Name  Since our Source Type is  couchbase , the Source Name should be\nname of a bucket.  Next, type in your bucket's name into the Source Name field.  For example, to index the \"default\" bucket from your Couchbase\nserver, type in a Source Name of \"default\".  NOTE: if your bucket has a password, you can supply the password by\nclicking on the  Show advanced settings  checkbox, which will\ndisplay the  Source Params  JSON textarea.  Then, fill in the authUser  field in the JSON with the name of the Couchbase bucket\nand the  authPassword  field with the bucket's password.  Your new index  Finally, click the  Create Index  button.  You should see a summary page of your new full-text index.  The  Document Count  field on the index summary page is a snapshot\nof how many documents have been indexed so far.  You can click on the Refresh  button next to the Document Count in order to see\nindexing progress.", 
            "title": "Creating a full-text index"
        }, 
        {
            "location": "/#querying-your-full-text-index", 
            "text": "Next, click on the  Query  tab.  In the query field, type in a query term.  Hit enter/return to execute your first cbft full-text query!  You should see query results appearing below the query field.", 
            "title": "Querying your full-text index"
        }, 
        {
            "location": "/#using-the-rest-api", 
            "text": "You can also use the REST API to access your index.  For example, if your index is named  myFirstIndex , here's how you\ncan use the curl tool to check how many documents are indexed...  curl http://localhost:8095/api/index/myFirstIndex/count  Here's an example of using curl to query the  myFirstIndex ...  curl -XPOST --header Content-Type:text/json \\\n     -d '{\"size\":10,\"query\":{\"query\":\"your search string\"}}' \\\n     http://localhost:8095/api/index/myFirstIndex/query", 
            "title": "Using the REST API"
        }, 
        {
            "location": "/#where-to-go-next", 
            "text": "That's about it for getting started.  You can see the other command-line parameters of cbft with the -h  flag...  ./cbft -h  Additionally, cbft's web admin UI has more screens and features, so be\nsure to click around and explore!  Finally, don't forget to take a look at these additional documents...   Developer's guide  API reference  Administrator's guide  Links to more resources", 
            "title": "Where to go next"
        }, 
        {
            "location": "/#providing-your-feedback", 
            "text": "If you need help, would like to contribute feedback, or would like to\ntalk about the cbft with like-minded folks, please have a look at the Couchbase forums  and the links to more resources .  To report bugs or feature requests, please use the cbft issue tracker\ncurrently hosted at github .   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Providing your feedback"
        }, 
        {
            "location": "/dev-guide/overview/", 
            "text": "Developer's guide\n\n\nThe developer's guide has the following sections...\n\n\n\n\nKey concepts\n - the main concepts of cbft clusters and indexes\n\n\nIndex definitions\n - the attributes and operations to defining an index\n\n\nIndex queries\n - details on querying an index\n\n\nPerformance\n - considerations to increasing indexing and querying performance\n\n\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Developer's guide overview"
        }, 
        {
            "location": "/dev-guide/overview/#developers-guide", 
            "text": "The developer's guide has the following sections...   Key concepts  - the main concepts of cbft clusters and indexes  Index definitions  - the attributes and operations to defining an index  Index queries  - details on querying an index  Performance  - considerations to increasing indexing and querying performance    Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Developer's guide"
        }, 
        {
            "location": "/dev-guide/concepts/", 
            "text": "Key concepts\n\n\nIndex\n\n\nAn index, or \nLogical Index\n, defines a data system that supports fast\nlookup of documents based on query criteria.\n\n\nAn often used analogy is that an index of a database is similar to a\nbook index.  A book index is comprised of alphabetically sorted\nentries that allow readers to quickly locate relevant pages in the\nbook based on some search words.\n\n\nSimilarly, a cbft index allows users to quickly locate relevant\ndocuments from diferent data sources based on some search terms or\nquery criteria.\n\n\ncbft supports multiple types of indexes, such as full-text indexes\nand index aliases.\n\n\ncbft also supports multiple kinds of data sources.\n\n\nData Source\n\n\nThe data used to populate an index comes from a \nData Source\n, or\nsometimes just called a \nSource\n.\n\n\nA data source, for example, might be all the documents stored in a\nCouchbase bucket.\n\n\nAnother data source, for example, might be all the files in a\nsubdirectory tree that match some naming patterns.\n\n\nEach index is defined with a single data source.\n\n\nIndex Alias\n\n\nAn \nIndex Alias\n is a type of index that's a \"virtual index\" that\npoints to other, real indexes.\n\n\nSimilar to a symbolic link in a filesystem, an index alias allows a\nnaming level of indirection, so that applications can refer to a\nstable name (the alias' name) while administrators can dynamically\nretarget or re-point the index alias to different, real indexes.\n\n\nSimilar to an email list alias, too, an index alias in cbft can also\n\"fan-out\" and refer to multiple, real indexes.  A query on an index\nalias will be scatter-gather'ed by cbft to all of the actual, real\nindexes and cbft will provide merged results from those\nscatter-gather'ed queries.\n\n\nIndex Partition\n\n\nAt runtime, the data entries maintained in a cbft index will be split\ninto one or more partitions, or \nIndex Partition\n's.\n\n\nAn index partition is sometimes abbreviated as \"pindex\" or \"PIndex\",\nas you'll sometimes see in cbft's log files, stats entries and/or JSON\ndata.\n\n\nPut another way, a logical index is partitioned into one or more index\npartitions or \"pindexes\".\n\n\nSource Partition\n\n\nAn index partition is different than, but related to, the partitions\nfrom a data source, or \nSource Partition\n's.\n\n\nFor example, Couchbase has a concept of partitions of a bucket (a.k.a,\n\"vbuckets\").  So, a first index partition in cbft might be assigned to\ningest the data from some subset of source partitions or vbuckets.  A\nsecond index partition in cbft might be assigned to ingest the data\nfrom a different subset of source partitions or vbuckets.\n\n\nNode\n\n\nIndex partitions are an important part of cbft's design that allows\ncbft to support a scale-out, distributed cluster of cbft processes, or\ncbft \nNode\n's.\n\n\nUsers can deploy multiple cbft nodes and cluster them together in\norder to increase performance and/or increase availability via\nreplication.\n\n\nIndex partitions are dynamically assigned at runtime to one or more\ncbft nodes, depending on replication policies and an index partition\nassignment algorithm that attempts to achieve balanced workloads\nacross the cbft nodes in a cluster.\n\n\nEach node has a unique \nNode UUID\n and listens on a unique HTTP/REST\nIP address and port (a.k.a, the \nBindHttp\n command-line parameter on\nnode startup).\n\n\nA node's UUID and HTTP/REST IP address and port must be unique across\na cbft cluster.\n\n\nThe nodes in a cbft cluster must also all use the same Cfg provider.\n\n\nCfg\n\n\nA \nCfg\n (or \"config\") provider is a configuration-oriented data system\nrequired by cbft nodes.\n\n\nA cbft node will store its configuration data into a Cfg provider.\n\n\nFor example, index definitions and cluster information will be stored\ninto a Cfg provider.\n\n\nSome available Cfg providers...\n\n\n\n\n\n\nsimple - for basic, non-clustered usage; the simple Cfg provider\n  uses a local JSON file to store configuration data.  This is the\n  default Cfg provider and is intended primarily to simplify the\n  development-time experience and developer's usage of cbft.\n\n\n\n\n\n\ncouchbase - a Couchbase bucket is used to store configuration data.\n  A couchbase Cfg provider is often used for clustering multiple cbft\n  nodes together, where all the cbft nodes need to be connected to the\n  same Couchbase bucket for their configuration data.\n\n\n\n\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Key concepts"
        }, 
        {
            "location": "/dev-guide/concepts/#key-concepts", 
            "text": "", 
            "title": "Key concepts"
        }, 
        {
            "location": "/dev-guide/concepts/#index", 
            "text": "An index, or  Logical Index , defines a data system that supports fast\nlookup of documents based on query criteria.  An often used analogy is that an index of a database is similar to a\nbook index.  A book index is comprised of alphabetically sorted\nentries that allow readers to quickly locate relevant pages in the\nbook based on some search words.  Similarly, a cbft index allows users to quickly locate relevant\ndocuments from diferent data sources based on some search terms or\nquery criteria.  cbft supports multiple types of indexes, such as full-text indexes\nand index aliases.  cbft also supports multiple kinds of data sources.", 
            "title": "Index"
        }, 
        {
            "location": "/dev-guide/concepts/#data-source", 
            "text": "The data used to populate an index comes from a  Data Source , or\nsometimes just called a  Source .  A data source, for example, might be all the documents stored in a\nCouchbase bucket.  Another data source, for example, might be all the files in a\nsubdirectory tree that match some naming patterns.  Each index is defined with a single data source.", 
            "title": "Data Source"
        }, 
        {
            "location": "/dev-guide/concepts/#index-alias", 
            "text": "An  Index Alias  is a type of index that's a \"virtual index\" that\npoints to other, real indexes.  Similar to a symbolic link in a filesystem, an index alias allows a\nnaming level of indirection, so that applications can refer to a\nstable name (the alias' name) while administrators can dynamically\nretarget or re-point the index alias to different, real indexes.  Similar to an email list alias, too, an index alias in cbft can also\n\"fan-out\" and refer to multiple, real indexes.  A query on an index\nalias will be scatter-gather'ed by cbft to all of the actual, real\nindexes and cbft will provide merged results from those\nscatter-gather'ed queries.", 
            "title": "Index Alias"
        }, 
        {
            "location": "/dev-guide/concepts/#index-partition", 
            "text": "At runtime, the data entries maintained in a cbft index will be split\ninto one or more partitions, or  Index Partition 's.  An index partition is sometimes abbreviated as \"pindex\" or \"PIndex\",\nas you'll sometimes see in cbft's log files, stats entries and/or JSON\ndata.  Put another way, a logical index is partitioned into one or more index\npartitions or \"pindexes\".", 
            "title": "Index Partition"
        }, 
        {
            "location": "/dev-guide/concepts/#source-partition", 
            "text": "An index partition is different than, but related to, the partitions\nfrom a data source, or  Source Partition 's.  For example, Couchbase has a concept of partitions of a bucket (a.k.a,\n\"vbuckets\").  So, a first index partition in cbft might be assigned to\ningest the data from some subset of source partitions or vbuckets.  A\nsecond index partition in cbft might be assigned to ingest the data\nfrom a different subset of source partitions or vbuckets.", 
            "title": "Source Partition"
        }, 
        {
            "location": "/dev-guide/concepts/#node", 
            "text": "Index partitions are an important part of cbft's design that allows\ncbft to support a scale-out, distributed cluster of cbft processes, or\ncbft  Node 's.  Users can deploy multiple cbft nodes and cluster them together in\norder to increase performance and/or increase availability via\nreplication.  Index partitions are dynamically assigned at runtime to one or more\ncbft nodes, depending on replication policies and an index partition\nassignment algorithm that attempts to achieve balanced workloads\nacross the cbft nodes in a cluster.  Each node has a unique  Node UUID  and listens on a unique HTTP/REST\nIP address and port (a.k.a, the  BindHttp  command-line parameter on\nnode startup).  A node's UUID and HTTP/REST IP address and port must be unique across\na cbft cluster.  The nodes in a cbft cluster must also all use the same Cfg provider.", 
            "title": "Node"
        }, 
        {
            "location": "/dev-guide/concepts/#cfg", 
            "text": "A  Cfg  (or \"config\") provider is a configuration-oriented data system\nrequired by cbft nodes.  A cbft node will store its configuration data into a Cfg provider.  For example, index definitions and cluster information will be stored\ninto a Cfg provider.  Some available Cfg providers...    simple - for basic, non-clustered usage; the simple Cfg provider\n  uses a local JSON file to store configuration data.  This is the\n  default Cfg provider and is intended primarily to simplify the\n  development-time experience and developer's usage of cbft.    couchbase - a Couchbase bucket is used to store configuration data.\n  A couchbase Cfg provider is often used for clustering multiple cbft\n  nodes together, where all the cbft nodes need to be connected to the\n  same Couchbase bucket for their configuration data.     Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Cfg"
        }, 
        {
            "location": "/dev-guide/index-definitions/", 
            "text": "Index definition operations\n\n\nYou can list, retrieve, create and delete index definitions in cbft\nusing its REST API or using its web admin UI.\n\n\nPlease see the \nREST API reference\n for\ndocumentation on programmatically GET'ing, PUT'ing, and DELETE'ing\nindex definitions.\n\n\nUsing the web admin UI\n\n\nTo start cbft and its included web admin UI, please see the \ngetting\nstarted\n guide.\n\n\nTo create a new index\n\n\nThe \ngetting started\n guide also includes a basic\ntutorial on creating a full-text (bleve) index.\n\n\nTo create an index in the web admin UI, using your web browser:\n\n\n\n\n\n\nNavigate to the \nIndexes\n screen.\n\n\n\n\n\n\nClick on the \nNew Index\n button.\n\n\n\n\n\n\nEditing, cloning, deleting index definitions\n\n\nTo edit an index definition in the web admin UI, using your web\nbrowser:\n\n\n\n\n\n\nNavigate to the \nIndexes\n screen.\n\n\n\n\n\n\nThere you will find a list of the indexes, if any, that you had\n  previously defined.\n\n\n\n\n\n\nEach listed index will have buttons for these operations:\n\n\n\n\n\n\nthe index \nedit\n button allows you to update an index\n  definition.\n\n\n\n\n\n\nthe index \nclone\n button allows you to copy an index definition.\n\n\n\n\n\n\nthe index \ndelete\n button (trash can icon) allows you to delete\n  an index definition.\n\n\n\n\n\n\nNote: if you click on the index \ndelete\n button, you will have a\nchance to first confirm the index definition deletion operation.\nDeleting an index, importantly, is a permanent operation.\n\n\nIndex attributes\n\n\nAn index has several attributes, several of which are required to be\nspecified when defining index:\n\n\n\n\nIndex Name - \nrequired attribute\n\n\nIndex Type - \nrequired attribute\n\n\nIndex Params\n\n\nSource Type - \nrequired attribute\n\n\nSource Name\n\n\nSource Params\n\n\nSource UUID\n\n\nPlan Params\n\n\nIndex UUID - \nsystem generated / read-only\n\n\n\n\nIndex Name (indexName)\n\n\nAn index has a required name, or \nIndex Name\n, which is a unique\nidentifier for the index.\n\n\nAn index name is comprised of alphanumeric characters, hyphens and\nunderscores (no whitespace characters).  The first character of an\nindex name must be an alphabetic character (a-z or A-Z).\n\n\nIndex Type (indexType)\n\n\nAn index has a required type, or \nIndex Type\n.\n\n\nAn often used index type, for example, would be \nbleve\n, for\nfull-text indexing.\n\n\nSome available index types include...\n\n\n\n\n\n\nbleve\n - a full-text index powered by the\n  \nbleve\n full-text engine.\n\n\n\n\n\n\nblackhole\n - for testing; a blackhole index type ignores all\n  incoming data, and returns errors on any queries.\n\n\n\n\n\n\nalias\n - an index alias provides a naming level of indirection\n  to one or more actual, target indexes.\n\n\n\n\n\n\nMore information on the \nbleve\n and \nalias\n index types are\navailable further below in this document.\n\n\nIndex Params (indexParams)\n\n\nAn index has an optional \nIndex Params\n JSON attribute.\n\n\nThe interpretation of the index params depends on the index type.\n\n\nFor example, if the index type is \nbleve\n, then the index params\nincludes the JSON mapping information that is used to configure the\nbleve full-text engine.\n\n\nFor example, if the index type is \nalias\n, then the index params\nshould be the JSON that defines one or more target indexes for the\nindex alias.\n\n\nMore information on the \nbleve\n and \nalias\n index params JSON are\navailable further below in this document.\n\n\nSource Type (sourceType)\n\n\nAn index has a required \nSource Type\n, which specifies the kind of\ndata source that is used to populate the index.\n\n\nAn often used source type, for example, would be \ncouchbase\n,\nwhich would be used when a user wants to index all the documents that\nare stored in a Couchbase bucket.\n\n\nSome available source types include...\n\n\n\n\ncouchbase\n - a Couchbase Server bucket will be the data source.\n\n\nnil\n - for testing; a nil data source never has any data.\n\n\n\n\nMore information on the \ncouchbase\n source types are available\nfurther below in this document.\n\n\nSource Name (sourceName)\n\n\nAn index also has an optional \nSource Name\n, whose interpretation is\ndependent on the source type of the index.\n\n\nFor example, when the source type is \ncouchbase\n, then the source\nname is treated as a Couchbase bucket name, and the source params\nwould define any optional, additional parameters needed to connect\nthat named Couchbase bucket.\n\n\nSource Params (sourceParams)\n\n\nAn index also has an optional \nSource Params\n JSON attribute, whose\ninterpretation depends on the source type of the index.\n\n\nThe Source Params allow for extra parameters to be defined, and are\nusually advanced connection and tuning parameters for configuring how\ncbft should retrieve data from a data source.\n\n\nSource UUID (sourceUUID)\n\n\nAn index also has an optional \nSource UUID\n attribute, whose meaning\ndepends on the source type of the index.\n\n\nFor example, when the source type is \ncouchbase\n, then the source\nUUID, which is optional, is treated as a Couchbase bucket UUID, in\norder to allow a strict identification of the correct bucket.\n\n\nPlan Params (planParams)\n\n\nAn index has a \nPlan Params\n JSON attribute, by which a user can\nspecify how cbft should plan to partition the index and to allocate\nindex partitions across cbft nodes in a cbft cluster.\n\n\nAn example plan params JSON:\n\n\n{\n    \"maxPartitionsPerPIndex\": 20,\n    \"numReplicas\": 1,\n    \"hierarchyRules\": null,\n    \"nodePlanParams\": null,\n    \"planFrozen\": false\n}\n\n\n\nThe fields in a plan params include:\n\n\n\n\nmaxPartitionsPerPIndex\n: integer \n= 0\n\n\nnumReplicas\n: integer \n= 0\n\n\nhierarchyRules\n: JSON object\n\n\nnodePlanParams\n: JSON object\n\n\nplanFrozen\n: bool, frozen == true\n\n\n\n\nmaxPartitionsPerPIndex\n, or \"max number of source partitions per\nindex partition\", limits how many source partitions that cbft can\nassign to or allocate toto an index partition.\n\n\nA value of 0 means no limit, which effectively means that cbft will\njust allocate all source partitions to a single index partition.\n\n\nFor example, with a Couchbase bucket as your data source (the source\ntype is \ncouchbase\n), you will have 1024 source partitions (1024\nCouchbase \"vbuckets\"), and then:\n\n\nIf your \nmaxPartitionsPerPIndex\n is 0, then you would have a\nsingle index partition that will be assigned to be responsible for all\nvbuckets.\n\n\nIf your \nmaxPartitionsPerPIndex\n is 200, then you would have 6\nindex partitions...\n\n\n\n\nindex partition A covers vbuckets 0 through 199\n\n\nindex partition B covers vbuckets 200 through 399\n\n\nindex partition C covers vbuckets 400 through 599\n\n\nindex partition D covers vbuckets 600 through 799\n\n\nindex partition E covers vbuckets 800 through 999\n\n\nindex partition F covers vbuckets 1000 through 1023\n\n\n\n\ncbft actually uses unique hexadecimal hashes (like\n\"beer-sample_58dc74c09923851d_607744fc\") to identify those index\npartitions instead of simple alphabetic characters as shown above (the\n'A' through 'F' above).\n\n\nThe format of the index partition identifier is...\n\n\nindexName\n_\nindexUUID\n_\nhash-of-source-partition-identifiers\n\n\n\n\nnumReplicas\n defines how many additional index partitions\nreplicas cbft should allocate, not counting the first assigned index\npartition.\n\n\nFor example, a value of 1 for \nnumReplicas\n means there should be\ntwo copies: the first copy plus 1 replica copy of the index\npartitions.\n\n\nFor example, a value of 0 for \nnumReplicas\n means there should be\nonly the first copy and no extra replica copies of the index\npartitions.\n\n\nhierarchyRules\n defines replica allocation rules or policies for\nshelf/rack/row/zone awareness.\n\n\nTBD\n\n\nnodePlanParams\n defines rules on whether a node is paused for\nindex ingest and/or index queries are allowed for a given index or\nindex partition.\n\n\nTBD\n\n\nplanFrozen\n defines whether an index is frozen or paused for\nautomatic reassignment or rebalancing of index partitions.\n\n\nIndex UUID (indexUUID)\n\n\nThe cbft system generates and assigns a unique \nIndex UUID\n to an\nindex when an index definition is first created and whenever the index\ndefinition is updated.\n\n\nThat is, if you edit or update an index definition, the cbft system\nwill re-generate a new Index UUID for the changed index definition.\n\n\nWhen using the REST API to edit or update an index definition, you can\noptionally pass in the index definition's current \nindexUUID\n via\nthe \nprevIndexUUID\n parameter on your request to ensure that\nconcurrent clients are not inadvertently overwriting each other's\nchanges to an index definition.\n\n\nIndex types\n\n\nIndex type: bleve\n\n\nFor the \nbleve\n index type, here is an example, default index\nparams JSON:\n\n\n{\n  \"mapping\": {\n    \"default_mapping\": {\n      \"enabled\": true,\n      \"dynamic\": true,\n      \"default_analyzer\": \"\"\n    },\n    \"type_field\": \"_type\",\n    \"default_type\": \"_default\",\n    \"default_analyzer\": \"standard\",\n    \"default_datetime_parser\": \"dateTimeOptional\",\n    \"default_field\": \"_all\",\n    \"byte_array_converter\": \"json\",\n    \"analysis\": {}\n  },\n  \"store\": {\n    \"kvStoreName\": \"boltdb\"\n  }\n}\n\n\n\nThere are two \"top-level\" fields in that bleve index params JSON:\n\n\n\n\nmapping\n\n\nstore\n\n\n\n\nThe \nmapping\n field is a JSON sub-object and is a representation\nof bleve's \nIndexMapping\n configuration settings.\n\n\nThat is, the value of the \nmapping\n field is passed directly to\nthe bleve full-text engine's \nIndexMapping\n parser.\n\n\nA bleve \nIndexMapping\n is a complete, standalone, declarative\nconfiguration of a logical bleve full-text index.\n\n\nPlease see \nbleve's documentation\n for more\ninformation on the \nIndexMapping\n.\n\n\nThe \nstore\nfield is a JSON sub-object and is a representation of\nbleve's \nkvconfig\n configuration settings.\n\n\nNOTE: For web admin UI users, the \nstore\n field input textarea is\nhidden by default.  To make it visible, click on the \nShow advanced\nsettings\n checkbox in the index creation form or index edit form.\n\n\nThe \nstore\n field has an important sub-field: \nkvStoreName\n.\n\n\nThe \nkvStoreName\n defines the persistent storage implementation\nthat will be used for the bleve index.\n\n\nAllowed values for \nkvStoreName\n include:\n\n\n\n\n\n\n\"boltdb\"\n - a pure-golang key-value storage library\n\n\n\n\n\n\n\"mem\"\n - a memory-only \"storage\" implementation, that does not\n  actually persist index data entries to disk.\n\n\n\n\n\n\n\"goleveldb\"\n - a pure-golang re-implementation of the leveldb\n  storage library (EXPERIMENTAL)\n\n\n\n\n\n\nTBD (leveldb, forestdb, ...others...)\n\n\n\n\n\n\nThe other sub-fields under the \nstore\n JSON sub-object are\ndependent on the persistent storage implementation that is being used.\n\n\nNote: underneath the hood, both the parsed \nmapping\n and\n\nstore\n objects are used when cbft invoke's bleve's \nNewUsing\n\nAPI when cbft needs to construct a new full-text index.\n\n\nIndex type: alias\n\n\nFor the \nalias\n index type, here is an example, default index\nparams JSON:\n\n\n{\n  \"targets\": {\n    \"%yourIndexName%\": {\n      \"indexUUID\": \"\"\n    }\n  }\n}\n\n\n\nYou can specify one or more \"%yourIndexName%\" entries listed under the\n\ntargets\n sub-object.\n\n\nFor example, perhaps you wish to have a naming level-of-indirection so\nthat applications can make queries without any application-side\nreconfigurations.\n\n\nIn one scenario, perhaps you have a sales management application that\nmakes queries against a \"LastQuarterSales\" alias.  The alias is\ntargeted against a \"sales-2014-Q4\" index, such as...\n\n\n{\n  \"targets\": {\n    \"sales-2014-Q4\": {\n      \"indexUUID\": \"\"\n    }\n  }\n}\n\n\n\nLater, when 2015 Q1 sales data is completed (end of the quarter) and a\nnew index is built, \"sales-2015-Q1\", then the \"LastQuarterSales\" alias\ncan be retargetted by the administrator to point to the latest\n\"sales-2015-Q1\" index...\n\n\n{\n  \"targets\": {\n    \"sales-2015-Q1\": {\n      \"indexUUID\": \"\"\n    }\n  }\n}\n\n\n\nThe optional \nindexUUID\n field in the index alias definition\nallows you to exactly specify a specific target index definition via\nthe target index definition's \nindexUUID\n.\n\n\nIf the target index is redefined and its \nindexUUID\n value is\nregenerated or reassigned by cbft, then queries against an index alias\nwith a mismatched indexUUID will result in error responses.\n\n\nMulti-target index alias\n\n\nYou can also have an index alias point to more than one target index.\n\n\nFor example, perhaps you wish to have a LastSixMonthsSales alias.  It\ncan be configured to point to the last two quarters of real indexes...\n\n\n{\n  \"targets\": {\n    \"sales-2014-Q4\": {\n      \"indexUUID\": \"\"\n    },\n    \"sales-2015-Q1\": {\n      \"indexUUID\": \"\"\n    }\n  }\n}\n\n\n\nThis is also useful for situations where you have indexes holding data\nfrom different datasources, such as a \"product-catalog-index\",\n\"customer-index\", \"employee-index\", \"intranet-docs-index\".\n\n\nYou can then have a single index alias that points to all the above\ntarget indexes so that applications can query just a single endpoint\n(the index alias).\n\n\nSource types\n\n\nSource type: couchbase\n\n\nWhen your source type is \ncouchbase\n, and you'd like to index a\nCouchbase bucket that has a password, then you need to specify an\n\nauthUser\n and an \nauthPassword\n as part of the Source Params\n(\nsourceParams\n) JSON.\n\n\nFor example, perhaps you'd like to index a \nproduct-catalog\n\nCouchbase bucket.\n\n\nThen, in the Source Params JSON...\n\n\n\n\n\n\nspecify the \"authUser\" to be the bucket's name\n  (\n\"product-catalog\"\n).\n\n\n\n\n\n\nspecify the \"authPassword\" to be the bucket's password, such as\n  \"PassWordSellMore\" (the empty password is just \n\"\"\n).\n\n\n\n\n\n\nFor example, your Source Params JSON would then look like...\n\n\n{\n  \"authUser\": \"product-catalog\",\n  \"authPassword\": \"PassWordSellMore\",\n  \"clusterManagerBackoffFactor\": 0,\n  \"clusterManagerSleepInitMS\": 0,\n  \"clusterManagerSleepMaxMS\": 20000,\n  \"dataManagerBackoffFactor\": 0,\n  \"dataManagerSleepInitMS\": 0,\n  \"dataManagerSleepMaxMS\": 20000,\n  \"feedBufferSizeBytes\": 0,\n  \"feedBufferAckThreshold\": 0\n}\n\n\n\nThe other parameters are for specifying optional, advanced connection\ntuning and error-handling behavior for how cbft creates and manages\nCouchbase DCP (data change protocol) streams:\n\n\n\n\n\n\nclusterManagerBackoffFactor\n: float - numeric factor (like 1.5)\n  for how cbft should increase its sleep time in between retries when\n  re-connecting to a Couchbase cluster manager.\n\n\n\n\n\n\nclusterManagerSleepInitMS\n: int - initial sleep time\n  (millisecs) for cbft's first retry on re-connecting to a Couchbase\n  cluster manager.\n\n\n\n\n\n\nclusterManagerSleepMaxMS\n: int - maximum sleep time (millisecs)\n  between re-connection attempts to a Couchbase cluster manager.\n\n\n\n\n\n\ndataManagerBackoffFactor\n: float - numeric factor (like 1.5)\n  for how cbft should increase its sleep time in between retries when\n  re-connecting to a Couchbase data manager node\n  (memcached/ep-engine server).\n\n\n\n\n\n\ndataManagerSleepInitMS\n: int - initial sleep time (millisecs)\n  for cbft's first retry on re-connecting to a Couchbase data manager.\n\n\n\n\n\n\ndataManagerSleepMaxMS\n: int - maximum sleep time (millisecs)\n  between re-connection attempts to a Couchbase data manager.\n\n\n\n\n\n\nfeedBufferSizeBytes\n: int - buffer size in bytes provided\n  for DCP flow control.\n\n\n\n\n\n\nfeedBufferAckThreshold\n: float - used for DCP flow control and\n  buffer-ack messages when this percentage of\n  \nfeedBufferSizeBytes\n is reached.\n\n\n\n\n\n\nIndex definition REST API\n\n\nYou can use the REST API to create and manage your index definitions.\n\n\nFor example, using the curl command-line tool, here is an example of\ncreating an index definition.  The index definition will be named\n\nbeer-sample\n, will have index type of\n\nbleve\n, and will have the \"beer-sample\"\nbucket from Couchbase as its datasource...\n\n\ncurl -XPUT 'http://localhost:8095/api/index/myFirstIndex?indexType=bleve\nsourceType=couchbase'\n\n\n\nTo list all your index definitions, you can use...\n\n\ncurl http://localhost:8095/api/index\n\n\n\nHere's an example of using curl to delete that index definition...\n\n\ncurl -XDELETE http://localhost:8095/api/index/beer-sample\n\n\n\nFor more information on the REST API, please see the\n\nREST API reference\n documentation.\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Index definitions"
        }, 
        {
            "location": "/dev-guide/index-definitions/#index-definition-operations", 
            "text": "You can list, retrieve, create and delete index definitions in cbft\nusing its REST API or using its web admin UI.  Please see the  REST API reference  for\ndocumentation on programmatically GET'ing, PUT'ing, and DELETE'ing\nindex definitions.", 
            "title": "Index definition operations"
        }, 
        {
            "location": "/dev-guide/index-definitions/#using-the-web-admin-ui", 
            "text": "To start cbft and its included web admin UI, please see the  getting\nstarted  guide.", 
            "title": "Using the web admin UI"
        }, 
        {
            "location": "/dev-guide/index-definitions/#to-create-a-new-index", 
            "text": "The  getting started  guide also includes a basic\ntutorial on creating a full-text (bleve) index.  To create an index in the web admin UI, using your web browser:    Navigate to the  Indexes  screen.    Click on the  New Index  button.", 
            "title": "To create a new index"
        }, 
        {
            "location": "/dev-guide/index-definitions/#editing-cloning-deleting-index-definitions", 
            "text": "To edit an index definition in the web admin UI, using your web\nbrowser:    Navigate to the  Indexes  screen.    There you will find a list of the indexes, if any, that you had\n  previously defined.    Each listed index will have buttons for these operations:    the index  edit  button allows you to update an index\n  definition.    the index  clone  button allows you to copy an index definition.    the index  delete  button (trash can icon) allows you to delete\n  an index definition.    Note: if you click on the index  delete  button, you will have a\nchance to first confirm the index definition deletion operation.\nDeleting an index, importantly, is a permanent operation.", 
            "title": "Editing, cloning, deleting index definitions"
        }, 
        {
            "location": "/dev-guide/index-definitions/#index-attributes", 
            "text": "An index has several attributes, several of which are required to be\nspecified when defining index:   Index Name -  required attribute  Index Type -  required attribute  Index Params  Source Type -  required attribute  Source Name  Source Params  Source UUID  Plan Params  Index UUID -  system generated / read-only", 
            "title": "Index attributes"
        }, 
        {
            "location": "/dev-guide/index-definitions/#index-name-indexname", 
            "text": "An index has a required name, or  Index Name , which is a unique\nidentifier for the index.  An index name is comprised of alphanumeric characters, hyphens and\nunderscores (no whitespace characters).  The first character of an\nindex name must be an alphabetic character (a-z or A-Z).", 
            "title": "Index Name (indexName)"
        }, 
        {
            "location": "/dev-guide/index-definitions/#index-type-indextype", 
            "text": "An index has a required type, or  Index Type .  An often used index type, for example, would be  bleve , for\nfull-text indexing.  Some available index types include...    bleve  - a full-text index powered by the\n   bleve  full-text engine.    blackhole  - for testing; a blackhole index type ignores all\n  incoming data, and returns errors on any queries.    alias  - an index alias provides a naming level of indirection\n  to one or more actual, target indexes.    More information on the  bleve  and  alias  index types are\navailable further below in this document.", 
            "title": "Index Type (indexType)"
        }, 
        {
            "location": "/dev-guide/index-definitions/#index-params-indexparams", 
            "text": "An index has an optional  Index Params  JSON attribute.  The interpretation of the index params depends on the index type.  For example, if the index type is  bleve , then the index params\nincludes the JSON mapping information that is used to configure the\nbleve full-text engine.  For example, if the index type is  alias , then the index params\nshould be the JSON that defines one or more target indexes for the\nindex alias.  More information on the  bleve  and  alias  index params JSON are\navailable further below in this document.", 
            "title": "Index Params (indexParams)"
        }, 
        {
            "location": "/dev-guide/index-definitions/#source-type-sourcetype", 
            "text": "An index has a required  Source Type , which specifies the kind of\ndata source that is used to populate the index.  An often used source type, for example, would be  couchbase ,\nwhich would be used when a user wants to index all the documents that\nare stored in a Couchbase bucket.  Some available source types include...   couchbase  - a Couchbase Server bucket will be the data source.  nil  - for testing; a nil data source never has any data.   More information on the  couchbase  source types are available\nfurther below in this document.", 
            "title": "Source Type (sourceType)"
        }, 
        {
            "location": "/dev-guide/index-definitions/#source-name-sourcename", 
            "text": "An index also has an optional  Source Name , whose interpretation is\ndependent on the source type of the index.  For example, when the source type is  couchbase , then the source\nname is treated as a Couchbase bucket name, and the source params\nwould define any optional, additional parameters needed to connect\nthat named Couchbase bucket.", 
            "title": "Source Name (sourceName)"
        }, 
        {
            "location": "/dev-guide/index-definitions/#source-params-sourceparams", 
            "text": "An index also has an optional  Source Params  JSON attribute, whose\ninterpretation depends on the source type of the index.  The Source Params allow for extra parameters to be defined, and are\nusually advanced connection and tuning parameters for configuring how\ncbft should retrieve data from a data source.", 
            "title": "Source Params (sourceParams)"
        }, 
        {
            "location": "/dev-guide/index-definitions/#source-uuid-sourceuuid", 
            "text": "An index also has an optional  Source UUID  attribute, whose meaning\ndepends on the source type of the index.  For example, when the source type is  couchbase , then the source\nUUID, which is optional, is treated as a Couchbase bucket UUID, in\norder to allow a strict identification of the correct bucket.", 
            "title": "Source UUID (sourceUUID)"
        }, 
        {
            "location": "/dev-guide/index-definitions/#plan-params-planparams", 
            "text": "An index has a  Plan Params  JSON attribute, by which a user can\nspecify how cbft should plan to partition the index and to allocate\nindex partitions across cbft nodes in a cbft cluster.  An example plan params JSON:  {\n    \"maxPartitionsPerPIndex\": 20,\n    \"numReplicas\": 1,\n    \"hierarchyRules\": null,\n    \"nodePlanParams\": null,\n    \"planFrozen\": false\n}  The fields in a plan params include:   maxPartitionsPerPIndex : integer  = 0  numReplicas : integer  = 0  hierarchyRules : JSON object  nodePlanParams : JSON object  planFrozen : bool, frozen == true   maxPartitionsPerPIndex , or \"max number of source partitions per\nindex partition\", limits how many source partitions that cbft can\nassign to or allocate toto an index partition.  A value of 0 means no limit, which effectively means that cbft will\njust allocate all source partitions to a single index partition.  For example, with a Couchbase bucket as your data source (the source\ntype is  couchbase ), you will have 1024 source partitions (1024\nCouchbase \"vbuckets\"), and then:  If your  maxPartitionsPerPIndex  is 0, then you would have a\nsingle index partition that will be assigned to be responsible for all\nvbuckets.  If your  maxPartitionsPerPIndex  is 200, then you would have 6\nindex partitions...   index partition A covers vbuckets 0 through 199  index partition B covers vbuckets 200 through 399  index partition C covers vbuckets 400 through 599  index partition D covers vbuckets 600 through 799  index partition E covers vbuckets 800 through 999  index partition F covers vbuckets 1000 through 1023   cbft actually uses unique hexadecimal hashes (like\n\"beer-sample_58dc74c09923851d_607744fc\") to identify those index\npartitions instead of simple alphabetic characters as shown above (the\n'A' through 'F' above).  The format of the index partition identifier is...  indexName _ indexUUID _ hash-of-source-partition-identifiers   numReplicas  defines how many additional index partitions\nreplicas cbft should allocate, not counting the first assigned index\npartition.  For example, a value of 1 for  numReplicas  means there should be\ntwo copies: the first copy plus 1 replica copy of the index\npartitions.  For example, a value of 0 for  numReplicas  means there should be\nonly the first copy and no extra replica copies of the index\npartitions.  hierarchyRules  defines replica allocation rules or policies for\nshelf/rack/row/zone awareness.  TBD  nodePlanParams  defines rules on whether a node is paused for\nindex ingest and/or index queries are allowed for a given index or\nindex partition.  TBD  planFrozen  defines whether an index is frozen or paused for\nautomatic reassignment or rebalancing of index partitions.", 
            "title": "Plan Params (planParams)"
        }, 
        {
            "location": "/dev-guide/index-definitions/#index-uuid-indexuuid", 
            "text": "The cbft system generates and assigns a unique  Index UUID  to an\nindex when an index definition is first created and whenever the index\ndefinition is updated.  That is, if you edit or update an index definition, the cbft system\nwill re-generate a new Index UUID for the changed index definition.  When using the REST API to edit or update an index definition, you can\noptionally pass in the index definition's current  indexUUID  via\nthe  prevIndexUUID  parameter on your request to ensure that\nconcurrent clients are not inadvertently overwriting each other's\nchanges to an index definition.", 
            "title": "Index UUID (indexUUID)"
        }, 
        {
            "location": "/dev-guide/index-definitions/#index-types", 
            "text": "", 
            "title": "Index types"
        }, 
        {
            "location": "/dev-guide/index-definitions/#index-type-bleve", 
            "text": "For the  bleve  index type, here is an example, default index\nparams JSON:  {\n  \"mapping\": {\n    \"default_mapping\": {\n      \"enabled\": true,\n      \"dynamic\": true,\n      \"default_analyzer\": \"\"\n    },\n    \"type_field\": \"_type\",\n    \"default_type\": \"_default\",\n    \"default_analyzer\": \"standard\",\n    \"default_datetime_parser\": \"dateTimeOptional\",\n    \"default_field\": \"_all\",\n    \"byte_array_converter\": \"json\",\n    \"analysis\": {}\n  },\n  \"store\": {\n    \"kvStoreName\": \"boltdb\"\n  }\n}  There are two \"top-level\" fields in that bleve index params JSON:   mapping  store   The  mapping  field is a JSON sub-object and is a representation\nof bleve's  IndexMapping  configuration settings.  That is, the value of the  mapping  field is passed directly to\nthe bleve full-text engine's  IndexMapping  parser.  A bleve  IndexMapping  is a complete, standalone, declarative\nconfiguration of a logical bleve full-text index.  Please see  bleve's documentation  for more\ninformation on the  IndexMapping .  The  store field is a JSON sub-object and is a representation of\nbleve's  kvconfig  configuration settings.  NOTE: For web admin UI users, the  store  field input textarea is\nhidden by default.  To make it visible, click on the  Show advanced\nsettings  checkbox in the index creation form or index edit form.  The  store  field has an important sub-field:  kvStoreName .  The  kvStoreName  defines the persistent storage implementation\nthat will be used for the bleve index.  Allowed values for  kvStoreName  include:    \"boltdb\"  - a pure-golang key-value storage library    \"mem\"  - a memory-only \"storage\" implementation, that does not\n  actually persist index data entries to disk.    \"goleveldb\"  - a pure-golang re-implementation of the leveldb\n  storage library (EXPERIMENTAL)    TBD (leveldb, forestdb, ...others...)    The other sub-fields under the  store  JSON sub-object are\ndependent on the persistent storage implementation that is being used.  Note: underneath the hood, both the parsed  mapping  and store  objects are used when cbft invoke's bleve's  NewUsing \nAPI when cbft needs to construct a new full-text index.", 
            "title": "Index type: bleve"
        }, 
        {
            "location": "/dev-guide/index-definitions/#index-type-alias", 
            "text": "For the  alias  index type, here is an example, default index\nparams JSON:  {\n  \"targets\": {\n    \"%yourIndexName%\": {\n      \"indexUUID\": \"\"\n    }\n  }\n}  You can specify one or more \"%yourIndexName%\" entries listed under the targets  sub-object.  For example, perhaps you wish to have a naming level-of-indirection so\nthat applications can make queries without any application-side\nreconfigurations.  In one scenario, perhaps you have a sales management application that\nmakes queries against a \"LastQuarterSales\" alias.  The alias is\ntargeted against a \"sales-2014-Q4\" index, such as...  {\n  \"targets\": {\n    \"sales-2014-Q4\": {\n      \"indexUUID\": \"\"\n    }\n  }\n}  Later, when 2015 Q1 sales data is completed (end of the quarter) and a\nnew index is built, \"sales-2015-Q1\", then the \"LastQuarterSales\" alias\ncan be retargetted by the administrator to point to the latest\n\"sales-2015-Q1\" index...  {\n  \"targets\": {\n    \"sales-2015-Q1\": {\n      \"indexUUID\": \"\"\n    }\n  }\n}  The optional  indexUUID  field in the index alias definition\nallows you to exactly specify a specific target index definition via\nthe target index definition's  indexUUID .  If the target index is redefined and its  indexUUID  value is\nregenerated or reassigned by cbft, then queries against an index alias\nwith a mismatched indexUUID will result in error responses.  Multi-target index alias  You can also have an index alias point to more than one target index.  For example, perhaps you wish to have a LastSixMonthsSales alias.  It\ncan be configured to point to the last two quarters of real indexes...  {\n  \"targets\": {\n    \"sales-2014-Q4\": {\n      \"indexUUID\": \"\"\n    },\n    \"sales-2015-Q1\": {\n      \"indexUUID\": \"\"\n    }\n  }\n}  This is also useful for situations where you have indexes holding data\nfrom different datasources, such as a \"product-catalog-index\",\n\"customer-index\", \"employee-index\", \"intranet-docs-index\".  You can then have a single index alias that points to all the above\ntarget indexes so that applications can query just a single endpoint\n(the index alias).", 
            "title": "Index type: alias"
        }, 
        {
            "location": "/dev-guide/index-definitions/#source-types", 
            "text": "", 
            "title": "Source types"
        }, 
        {
            "location": "/dev-guide/index-definitions/#source-type-couchbase", 
            "text": "When your source type is  couchbase , and you'd like to index a\nCouchbase bucket that has a password, then you need to specify an authUser  and an  authPassword  as part of the Source Params\n( sourceParams ) JSON.  For example, perhaps you'd like to index a  product-catalog \nCouchbase bucket.  Then, in the Source Params JSON...    specify the \"authUser\" to be the bucket's name\n  ( \"product-catalog\" ).    specify the \"authPassword\" to be the bucket's password, such as\n  \"PassWordSellMore\" (the empty password is just  \"\" ).    For example, your Source Params JSON would then look like...  {\n  \"authUser\": \"product-catalog\",\n  \"authPassword\": \"PassWordSellMore\",\n  \"clusterManagerBackoffFactor\": 0,\n  \"clusterManagerSleepInitMS\": 0,\n  \"clusterManagerSleepMaxMS\": 20000,\n  \"dataManagerBackoffFactor\": 0,\n  \"dataManagerSleepInitMS\": 0,\n  \"dataManagerSleepMaxMS\": 20000,\n  \"feedBufferSizeBytes\": 0,\n  \"feedBufferAckThreshold\": 0\n}  The other parameters are for specifying optional, advanced connection\ntuning and error-handling behavior for how cbft creates and manages\nCouchbase DCP (data change protocol) streams:    clusterManagerBackoffFactor : float - numeric factor (like 1.5)\n  for how cbft should increase its sleep time in between retries when\n  re-connecting to a Couchbase cluster manager.    clusterManagerSleepInitMS : int - initial sleep time\n  (millisecs) for cbft's first retry on re-connecting to a Couchbase\n  cluster manager.    clusterManagerSleepMaxMS : int - maximum sleep time (millisecs)\n  between re-connection attempts to a Couchbase cluster manager.    dataManagerBackoffFactor : float - numeric factor (like 1.5)\n  for how cbft should increase its sleep time in between retries when\n  re-connecting to a Couchbase data manager node\n  (memcached/ep-engine server).    dataManagerSleepInitMS : int - initial sleep time (millisecs)\n  for cbft's first retry on re-connecting to a Couchbase data manager.    dataManagerSleepMaxMS : int - maximum sleep time (millisecs)\n  between re-connection attempts to a Couchbase data manager.    feedBufferSizeBytes : int - buffer size in bytes provided\n  for DCP flow control.    feedBufferAckThreshold : float - used for DCP flow control and\n  buffer-ack messages when this percentage of\n   feedBufferSizeBytes  is reached.", 
            "title": "Source type: couchbase"
        }, 
        {
            "location": "/dev-guide/index-definitions/#index-definition-rest-api", 
            "text": "You can use the REST API to create and manage your index definitions.  For example, using the curl command-line tool, here is an example of\ncreating an index definition.  The index definition will be named beer-sample , will have index type of bleve , and will have the \"beer-sample\"\nbucket from Couchbase as its datasource...  curl -XPUT 'http://localhost:8095/api/index/myFirstIndex?indexType=bleve sourceType=couchbase'  To list all your index definitions, you can use...  curl http://localhost:8095/api/index  Here's an example of using curl to delete that index definition...  curl -XDELETE http://localhost:8095/api/index/beer-sample  For more information on the REST API, please see the REST API reference  documentation.   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Index definition REST API"
        }, 
        {
            "location": "/dev-guide/index-queries/", 
            "text": "Index queries\n\n\nYou can query indexes either using cbft's REST API or using its web\nadmin UI.\n\n\nWeb admin UI queries\n\n\nYou can use cbft's web admin UI in order to query an index using your\nweb browser:\n\n\n\n\n\n\nNavigate to the \nIndexes\n screen.\n\n\n\n\n\n\nClick on your index's name link to navigate to your index's summary\n  screen.\n\n\n\n\n\n\nClick on the \nQuery\n tab for your index.\n\n\n\n\n\n\nEnter your query statement in the input field.\n\n\n\n\n\n\nThe kind of query statement you can enter depends on your index's\ntype.\n\n\nPlease see below in this document for more information on the query\nstatement requirements for the different index types.\n\n\n\n\nYou can click on the \nAdvanced\n checkbox in order to see\n  more optional, advanced query parameters.\n\n\n\n\nREST API queries\n\n\nPlease see the \nREST API reference\n for documentation on\nprogrammatically POST'ing query requests to cbft.\n\n\nYou can POST a query request to any cbft node in a cbft cluster.\n\n\nTo process your query request, the cbft node that receives your REST\nquery will then in turn perform distributed requests against the other\nnodes in the cbft cluster and gather their responses.\n\n\nYour REST client will then receive a processed, merged response from\nthe cbft node that received the original REST query request.\n\n\nProgrammatically, the POST body for REST API \nbleve\n queries would\nlook similar to the following example JSON:\n\n\n{\n  \"ctl\": {\n    \"timeout\": 0,\n    \"consistency\": {\n      \"level\": \"\",\n      \"vectors\": {}\n    },\n  },\n  \"query\": {\n    \"boost\": 1.0,\n    \"query\": \"your query string here\"\n  }\n}\n\n\n\nThere are several common fields:\n\n\n\n\n\n\nctl\n - an optional JSON sub-object that contains generic query\n  request control information, such as \ntimeout\n and\n  \nconsistency\n.\n\n\n\n\n\n\ntimeout\n - an optional integer in the \nctl\n JSON\n  sub-object, timeout in milliseconds, 0 for no timeout.\n\n\n\n\n\n\nconsistency\n - an optional JSON sub-object in the \nctl\n\n  JSON sub-object to ensure that the index has reached a consistency\n  level required by the application, where the index has incorporated\n  enough required data from the data source of the index.  See below\n  in this document for more information.\n\n\n\n\n\n\nIndex types and queries\n\n\nIndex type: bleve\n\n\nWhen using the \nbleve\n index type, the query statement that you\nuse in cbft's web admin UI must follow bleve's full-text index \nquery\nstring\n\nsyntax rules.\n\n\nSee: \nhttps://github.com/blevesearch/bleve/wiki/Query%20String%20Query\n\n\nAn example JSON for querying the \nbleve\n index type:\n\n\n{\n  \"ctl\": {\n    \"timeout\": 10000,    // Optional timeout, in milliseconds.\n    \"consistency\": {     // Optionally wait for index consistency.\n      \"level\": \"\",       // \"\" means wait that a stale index is ok to query.\n                         // \"at_plus\" means index must incorporate\n                         // the latest mutations up to the following optional vectors.\n      \"vectors\": {\n        \"yourIndexName\": { // This JSON map is keyed by strings of\n                           // \"partitionId\" (vbucketId) or by\n                           // \"partitionId/partitionUUID\" (vbucketId/vbucketUUID).\n                           // Values are data-source partition (vbucket)\n                           // sequence numbers that must incorporated\n                           // into the index before the query can proceed.\n          \"0\": 123,        // This example means the index partition for\n                           // partitionId \"0\" (or vbucketId 0) must\n                           // reach at least sequence number 123 before\n                           // the query can proceeed (or timeout).\n          \"1\": 444,        // The index partition for partitionId \"1\" (or vbucketId 1)\n                           // must reach at least sequence number 444\n                           // before the query can proceed (or timeout).\n          \"2/a0b1c2\": 555  // The index partition for partitionId \"2\" (or vbucketId 2)\n                           // which must have partition (or vbucket) UUID of \"a0b1c2\"\n                           // must reach at least sequence nubmer 555\n                           // before the query can proceed (or timeout).\n        }\n      }\n    },\n  },\n  // The remaining top-level fields come from bleve.SearchRequest.\n  \"query\": : {\n    \"boost\": 1.0,\n    \"query\": \"your bleve query string here\"\n  },\n  \"size\": 10,         // Limit the number of results that are returned.\n  \"from\": 0,          // Offset position of the first result returned,\n                      // starting from 0, used for resultset paging.\n  \"highlight\": null,  // See bleve's Highlight API for result snippet highlighting.\n  \"fields\": [ \"*\" ],  // Restricts the fields that bleve considers during the search.\n  \"facets\": null,     // For bleve's faceted search features.\n  \"explain\": false    // When true, bleve will provide scoring explaination.\n}\n\n\n\nScoring\n\n\nTBD\n\n\nPagination\n\n\nTBD\n\n\nResults highlighting\n\n\nTBD\n\n\nFaceted searches\n\n\nTBD\n\n\nIndex document counts\n\n\nTBD\n\n\nIndex consistency\n\n\nTBD\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Index queries"
        }, 
        {
            "location": "/dev-guide/index-queries/#index-queries", 
            "text": "You can query indexes either using cbft's REST API or using its web\nadmin UI.", 
            "title": "Index queries"
        }, 
        {
            "location": "/dev-guide/index-queries/#web-admin-ui-queries", 
            "text": "You can use cbft's web admin UI in order to query an index using your\nweb browser:    Navigate to the  Indexes  screen.    Click on your index's name link to navigate to your index's summary\n  screen.    Click on the  Query  tab for your index.    Enter your query statement in the input field.    The kind of query statement you can enter depends on your index's\ntype.  Please see below in this document for more information on the query\nstatement requirements for the different index types.   You can click on the  Advanced  checkbox in order to see\n  more optional, advanced query parameters.", 
            "title": "Web admin UI queries"
        }, 
        {
            "location": "/dev-guide/index-queries/#rest-api-queries", 
            "text": "Please see the  REST API reference  for documentation on\nprogrammatically POST'ing query requests to cbft.  You can POST a query request to any cbft node in a cbft cluster.  To process your query request, the cbft node that receives your REST\nquery will then in turn perform distributed requests against the other\nnodes in the cbft cluster and gather their responses.  Your REST client will then receive a processed, merged response from\nthe cbft node that received the original REST query request.  Programmatically, the POST body for REST API  bleve  queries would\nlook similar to the following example JSON:  {\n  \"ctl\": {\n    \"timeout\": 0,\n    \"consistency\": {\n      \"level\": \"\",\n      \"vectors\": {}\n    },\n  },\n  \"query\": {\n    \"boost\": 1.0,\n    \"query\": \"your query string here\"\n  }\n}  There are several common fields:    ctl  - an optional JSON sub-object that contains generic query\n  request control information, such as  timeout  and\n   consistency .    timeout  - an optional integer in the  ctl  JSON\n  sub-object, timeout in milliseconds, 0 for no timeout.    consistency  - an optional JSON sub-object in the  ctl \n  JSON sub-object to ensure that the index has reached a consistency\n  level required by the application, where the index has incorporated\n  enough required data from the data source of the index.  See below\n  in this document for more information.", 
            "title": "REST API queries"
        }, 
        {
            "location": "/dev-guide/index-queries/#index-types-and-queries", 
            "text": "", 
            "title": "Index types and queries"
        }, 
        {
            "location": "/dev-guide/index-queries/#index-type-bleve", 
            "text": "When using the  bleve  index type, the query statement that you\nuse in cbft's web admin UI must follow bleve's full-text index  query\nstring \nsyntax rules.  See:  https://github.com/blevesearch/bleve/wiki/Query%20String%20Query  An example JSON for querying the  bleve  index type:  {\n  \"ctl\": {\n    \"timeout\": 10000,    // Optional timeout, in milliseconds.\n    \"consistency\": {     // Optionally wait for index consistency.\n      \"level\": \"\",       // \"\" means wait that a stale index is ok to query.\n                         // \"at_plus\" means index must incorporate\n                         // the latest mutations up to the following optional vectors.\n      \"vectors\": {\n        \"yourIndexName\": { // This JSON map is keyed by strings of\n                           // \"partitionId\" (vbucketId) or by\n                           // \"partitionId/partitionUUID\" (vbucketId/vbucketUUID).\n                           // Values are data-source partition (vbucket)\n                           // sequence numbers that must incorporated\n                           // into the index before the query can proceed.\n          \"0\": 123,        // This example means the index partition for\n                           // partitionId \"0\" (or vbucketId 0) must\n                           // reach at least sequence number 123 before\n                           // the query can proceeed (or timeout).\n          \"1\": 444,        // The index partition for partitionId \"1\" (or vbucketId 1)\n                           // must reach at least sequence number 444\n                           // before the query can proceed (or timeout).\n          \"2/a0b1c2\": 555  // The index partition for partitionId \"2\" (or vbucketId 2)\n                           // which must have partition (or vbucket) UUID of \"a0b1c2\"\n                           // must reach at least sequence nubmer 555\n                           // before the query can proceed (or timeout).\n        }\n      }\n    },\n  },\n  // The remaining top-level fields come from bleve.SearchRequest.\n  \"query\": : {\n    \"boost\": 1.0,\n    \"query\": \"your bleve query string here\"\n  },\n  \"size\": 10,         // Limit the number of results that are returned.\n  \"from\": 0,          // Offset position of the first result returned,\n                      // starting from 0, used for resultset paging.\n  \"highlight\": null,  // See bleve's Highlight API for result snippet highlighting.\n  \"fields\": [ \"*\" ],  // Restricts the fields that bleve considers during the search.\n  \"facets\": null,     // For bleve's faceted search features.\n  \"explain\": false    // When true, bleve will provide scoring explaination.\n}  Scoring  TBD  Pagination  TBD  Results highlighting  TBD  Faceted searches  TBD", 
            "title": "Index type: bleve"
        }, 
        {
            "location": "/dev-guide/index-queries/#index-document-counts", 
            "text": "TBD", 
            "title": "Index document counts"
        }, 
        {
            "location": "/dev-guide/index-queries/#index-consistency", 
            "text": "TBD   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Index consistency"
        }, 
        {
            "location": "/dev-guide/performance/", 
            "text": "Increasing performance\n\n\nThere are several aspects to consider on increasing the performance of\nyour indexes.\n\n\nEspecially, there are often with competing tradeoffs at play, in\nparticular:\n\n\n\n\n\n\nindexing performance, or ingest performance - this is the speed at\n  which the indexing system can incorporate data from a data source.\n\n\n\n\n\n\nquery performance - this is how fast the system responds to a query.\n\n\n\n\n\n\nAdditionally, there are also the classic, additonal tradeoffs or\ndimensions of speed: latency versus throughput.\n\n\nUnderlying it all, finally, is cost, regarding the resources that you\ncan deploy to meet a required level of performance and the\nadministration and maintenance of those resources.\n\n\nThere are several ways to address the above aspects...\n\n\nScale up\n\n\nA easy to understand approach, often without changing any other\napplication dependencies or configuration assumptions, is to increase\nthe power of each cbft node, with additional and/or more powerful\nCPU's, more RAM, and faster storage (e.g., SSD's).\n\n\nScale out\n\n\nA related approach, in contrast, would be to add more nodes to a cbft\ncluster.\n\n\nThese \"scale out\" nodes might individually be cheaper than \"scale up\"\nmachines, but collectively have more power as a cluster than a cluster\nof powerful nodes.\n\n\nEspecially, with a granular level of index partitions (many index\npartitions), those index partitions can be distributed across many\nnodes to harness the collective CPU and I/O throughput of the\nmultiple, cheaper machines.  With enough networking bandwidth, this\ncan increase indexing or ingest throughput.\n\n\nBut, not all is free with scale-out: more index partitions spread out\nacross more nodes can be detrimental to query performance.\n\n\nQueries are scatter/gather\n\n\ncbft must distribute a query request to every index partition\n(scatter) and merge/coallesce the results (gather) before returning a\nfinal response back to a query client.\n\n\nWith a scale-out cluster of many machines (in order to get higher\nindexing throughput), this might reduce query performance.\n\n\nQuery-only cbft nodes\n\n\nAdvanced: cbft has the ability to run nodes that are \"query only\".\nThese cbft nodes will not performance any indexing work nor directly\nmanage or maintain any stored index data, but only respond to query\nrequests and perform the querying scatter/gather work.\n\n\nYou can then use cheaper machines for these query-only nodes, as they\ndon't need fast I/O storage capabilities, so you can more easily have\nmany more query-only nodes deployed.\n\n\nTo run a cbft node in query-only mode, see the \n-tags\n\ncommand-line flag, with the \nqueryer\n tag.  For example...\n\n\n./cbft -tags queryer [...other cbft params...]\n\n\n\nTighter selectivity\n\n\nConsider, for example, the case where you're searching an index of a\ncustomer service issues database.\n\n\nIf the search term is the word \"problem\", the it's likely that every\nsingle index partition will have index entires for the \"problem\" term,\nleading to a lot of results that need to be retrieved and\nmerged/collasced during a query of \"problem\".\n\n\nIn contrast, if the search term is something highly selective, like\nthe word \"IRx0003914\", then perhaps only a very few index partitions\nwith have index entries for that unique, uncommon term.  Most index\npartitions will have empty results, which are much easy to\nmerge/coallesce at higher performance.\n\n\nAn application developer can leverage this behavior with UI or other\napplication approaches that send queries for special terms to\npurposefully defined indexes that support tighter selectivity.\n\n\nSmaller indexes\n\n\nA related approach to increase performance is to reduce index sizes\n\n\nSome index types such as the \nbleve\n full-text engine include\nfeatures to filter away parts of documents, such as by ignoring\ncertain fields, not storing entire documents, and not storing\ncontextual information such as to enable search hit highlighting.\n\n\nIf the application requirements allow turning off or not utilizing\nthose advanced features, you can reduce index sizes to increase\nperformance.\n\n\nSmaller index sizes can be more completely cached in memory, which\nallows cbft to avoid expensive I/O storage accesses, and hence also\nincrease performance.\n\n\nHeterogeneous node capabilities\n\n\ncbft also supports the ability for a cbft cluster to be comprised of a\nmix of different machine capabilities, where some machines may be\nbigger or more powerful than others.\n\n\ncbft can utilize the more powerful machines by assigning those\nmachines more index partitions than the less powerful machines.\n\n\nTo tell cbft that a machine is more powerful, please see the\n\n-weight\n command-line flag.  For example...\n\n\n./cbft -weight 2 [...other cbft params...]\n\n\n\nRelaxing consistency\n\n\ncbft includes the optional ability when processing a query to ensure\nthat indexes are \"caught up\", where all the latest data from the data\nsource has been incorporated into the index, before the query\nprocessing proceeeds.\n\n\nThis allows an application to \"read your own writes\" (RYOW), where\nquery results will reflect the latest mutations done by an application\nthread.\n\n\nHowever, if application requirements allow, cbft supports the ability\nto instead query the index even if the index is out of date.  This may\nbe useful for some cases to increase the apparent or perceived\nperformance to the users of the overall application, at the tradeoff\nof sometimes receiving older or \"stale\" index results.\n\n\nAdvanced storage options\n\n\nTBD\n\n\nCompacting data\n\n\nTBD\n\n\nTesting and experiments\n\n\nAt the end of all these complex design tradeoffs and theories, the\nultimate answers will come from real-world data and results from\ntesting and experiments on actual hardware and datasets.\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Performance"
        }, 
        {
            "location": "/dev-guide/performance/#increasing-performance", 
            "text": "There are several aspects to consider on increasing the performance of\nyour indexes.  Especially, there are often with competing tradeoffs at play, in\nparticular:    indexing performance, or ingest performance - this is the speed at\n  which the indexing system can incorporate data from a data source.    query performance - this is how fast the system responds to a query.    Additionally, there are also the classic, additonal tradeoffs or\ndimensions of speed: latency versus throughput.  Underlying it all, finally, is cost, regarding the resources that you\ncan deploy to meet a required level of performance and the\nadministration and maintenance of those resources.  There are several ways to address the above aspects...", 
            "title": "Increasing performance"
        }, 
        {
            "location": "/dev-guide/performance/#scale-up", 
            "text": "A easy to understand approach, often without changing any other\napplication dependencies or configuration assumptions, is to increase\nthe power of each cbft node, with additional and/or more powerful\nCPU's, more RAM, and faster storage (e.g., SSD's).", 
            "title": "Scale up"
        }, 
        {
            "location": "/dev-guide/performance/#scale-out", 
            "text": "A related approach, in contrast, would be to add more nodes to a cbft\ncluster.  These \"scale out\" nodes might individually be cheaper than \"scale up\"\nmachines, but collectively have more power as a cluster than a cluster\nof powerful nodes.  Especially, with a granular level of index partitions (many index\npartitions), those index partitions can be distributed across many\nnodes to harness the collective CPU and I/O throughput of the\nmultiple, cheaper machines.  With enough networking bandwidth, this\ncan increase indexing or ingest throughput.  But, not all is free with scale-out: more index partitions spread out\nacross more nodes can be detrimental to query performance.", 
            "title": "Scale out"
        }, 
        {
            "location": "/dev-guide/performance/#queries-are-scattergather", 
            "text": "cbft must distribute a query request to every index partition\n(scatter) and merge/coallesce the results (gather) before returning a\nfinal response back to a query client.  With a scale-out cluster of many machines (in order to get higher\nindexing throughput), this might reduce query performance.", 
            "title": "Queries are scatter/gather"
        }, 
        {
            "location": "/dev-guide/performance/#query-only-cbft-nodes", 
            "text": "Advanced: cbft has the ability to run nodes that are \"query only\".\nThese cbft nodes will not performance any indexing work nor directly\nmanage or maintain any stored index data, but only respond to query\nrequests and perform the querying scatter/gather work.  You can then use cheaper machines for these query-only nodes, as they\ndon't need fast I/O storage capabilities, so you can more easily have\nmany more query-only nodes deployed.  To run a cbft node in query-only mode, see the  -tags \ncommand-line flag, with the  queryer  tag.  For example...  ./cbft -tags queryer [...other cbft params...]", 
            "title": "Query-only cbft nodes"
        }, 
        {
            "location": "/dev-guide/performance/#tighter-selectivity", 
            "text": "Consider, for example, the case where you're searching an index of a\ncustomer service issues database.  If the search term is the word \"problem\", the it's likely that every\nsingle index partition will have index entires for the \"problem\" term,\nleading to a lot of results that need to be retrieved and\nmerged/collasced during a query of \"problem\".  In contrast, if the search term is something highly selective, like\nthe word \"IRx0003914\", then perhaps only a very few index partitions\nwith have index entries for that unique, uncommon term.  Most index\npartitions will have empty results, which are much easy to\nmerge/coallesce at higher performance.  An application developer can leverage this behavior with UI or other\napplication approaches that send queries for special terms to\npurposefully defined indexes that support tighter selectivity.", 
            "title": "Tighter selectivity"
        }, 
        {
            "location": "/dev-guide/performance/#smaller-indexes", 
            "text": "A related approach to increase performance is to reduce index sizes  Some index types such as the  bleve  full-text engine include\nfeatures to filter away parts of documents, such as by ignoring\ncertain fields, not storing entire documents, and not storing\ncontextual information such as to enable search hit highlighting.  If the application requirements allow turning off or not utilizing\nthose advanced features, you can reduce index sizes to increase\nperformance.  Smaller index sizes can be more completely cached in memory, which\nallows cbft to avoid expensive I/O storage accesses, and hence also\nincrease performance.", 
            "title": "Smaller indexes"
        }, 
        {
            "location": "/dev-guide/performance/#heterogeneous-node-capabilities", 
            "text": "cbft also supports the ability for a cbft cluster to be comprised of a\nmix of different machine capabilities, where some machines may be\nbigger or more powerful than others.  cbft can utilize the more powerful machines by assigning those\nmachines more index partitions than the less powerful machines.  To tell cbft that a machine is more powerful, please see the -weight  command-line flag.  For example...  ./cbft -weight 2 [...other cbft params...]", 
            "title": "Heterogeneous node capabilities"
        }, 
        {
            "location": "/dev-guide/performance/#relaxing-consistency", 
            "text": "cbft includes the optional ability when processing a query to ensure\nthat indexes are \"caught up\", where all the latest data from the data\nsource has been incorporated into the index, before the query\nprocessing proceeeds.  This allows an application to \"read your own writes\" (RYOW), where\nquery results will reflect the latest mutations done by an application\nthread.  However, if application requirements allow, cbft supports the ability\nto instead query the index even if the index is out of date.  This may\nbe useful for some cases to increase the apparent or perceived\nperformance to the users of the overall application, at the tradeoff\nof sometimes receiving older or \"stale\" index results.", 
            "title": "Relaxing consistency"
        }, 
        {
            "location": "/dev-guide/performance/#advanced-storage-options", 
            "text": "TBD", 
            "title": "Advanced storage options"
        }, 
        {
            "location": "/dev-guide/performance/#compacting-data", 
            "text": "TBD", 
            "title": "Compacting data"
        }, 
        {
            "location": "/dev-guide/performance/#testing-and-experiments", 
            "text": "At the end of all these complex design tradeoffs and theories, the\nultimate answers will come from real-world data and results from\ntesting and experiments on actual hardware and datasets.   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Testing and experiments"
        }, 
        {
            "location": "/api-ref/", 
            "text": "API Reference\n\n\n\n\nIndexing\n\n\n\n\nIndex definition\n\n\n\n\nGET \n/api/index\n\n\nReturns all index definitions as JSON.\n\n\nversion introduced\n: 0.0.1\n\n\nSample response:\n\n\n{\n  \"indexDefs\": {\n    \"implVersion\": \"4.0.0\",\n    \"indexDefs\": {\n      \"myFirstIndex\": {\n        \"name\": \"myFirstIndex\",\n        \"params\": \"\",\n        \"planParams\": {\n          \"hierarchyRules\": null,\n          \"maxPartitionsPerPIndex\": 0,\n          \"nodePlanParams\": null,\n          \"numReplicas\": 0,\n          \"planFrozen\": false\n        },\n        \"sourceName\": \"\",\n        \"sourceParams\": \"\",\n        \"sourceType\": \"nil\",\n        \"sourceUUID\": \"\",\n        \"type\": \"blackhole\",\n        \"uuid\": \"6cc599ab7a85bf3b\"\n      }\n    },\n    \"uuid\": \"6cc599ab7a85bf3b\"\n  },\n  \"status\": \"ok\"\n}\n\n\n\n\n\nGET \n/api/index/{indexName}\n\n\nReturns the definition of an index as JSON.\n\n\nparam: indexName\n: required, string, URL path parameter\n\n\nThe name of the index definition to be retrieved.\n\n\nversion introduced\n: 0.0.1\n\n\nSample response:\n\n\n{\n  \"indexDef\": {\n    \"name\": \"myFirstIndex\",\n    \"params\": \"\",\n    \"planParams\": {\n      \"hierarchyRules\": null,\n      \"maxPartitionsPerPIndex\": 0,\n      \"nodePlanParams\": null,\n      \"numReplicas\": 0,\n      \"planFrozen\": false\n    },\n    \"sourceName\": \"\",\n    \"sourceParams\": \"\",\n    \"sourceType\": \"nil\",\n    \"sourceUUID\": \"\",\n    \"type\": \"blackhole\",\n    \"uuid\": \"6cc599ab7a85bf3b\"\n  },\n  \"planPIndexes\": [\n    {\n      \"indexName\": \"myFirstIndex\",\n      \"indexParams\": \"\",\n      \"indexType\": \"blackhole\",\n      \"indexUUID\": \"6cc599ab7a85bf3b\",\n      \"name\": \"myFirstIndex_6cc599ab7a85bf3b_0\",\n      \"nodes\": {\n        \"78fc2ffac2fd9401\": {\n          \"canRead\": true,\n          \"canWrite\": true,\n          \"priority\": 0\n        }\n      },\n      \"sourceName\": \"\",\n      \"sourceParams\": \"\",\n      \"sourcePartitions\": \"\",\n      \"sourceType\": \"nil\",\n      \"sourceUUID\": \"\",\n      \"uuid\": \"64bed6e2edf354c3\"\n    }\n  ],\n  \"status\": \"ok\",\n  \"warnings\": []\n}\n\n\n\n\n\nPUT \n/api/index/{indexName}\n\n\nCreates/updates an index definition.\n\n\nparam: indexName\n: required, string, URL path parameter\n\n\nThe name of the to-be-created/updated index definition,\nvalidated with the regular expression of \n^[A-Za-z][0-9A-Za-z_\\-]*$\n.\n\n\nparam: indexParams\n: optional (depends on the value of the indexType), string (JSON), form parameter\n\n\nFor indexType \nalias\n, an example indexParams JSON:\n\n\n{\n  \"targets\": {\n    \"yourIndexName\": {\n      \"indexUUID\": \"\"\n    }\n  }\n}\n\n\n\nFor indexType \nblackhole\n, the indexParams can be null.\n\n\nFor indexType \nbleve\n, an example indexParams JSON:\n\n\n{\n  \"mapping\": {\n    \"default_mapping\": {\n      \"enabled\": true,\n      \"dynamic\": true,\n      \"default_analyzer\": \"\"\n    },\n    \"type_field\": \"_type\",\n    \"default_type\": \"_default\",\n    \"default_analyzer\": \"standard\",\n    \"default_datetime_parser\": \"dateTimeOptional\",\n    \"default_field\": \"_all\",\n    \"byte_array_converter\": \"json\",\n    \"analysis\": {}\n  },\n  \"store\": {\n    \"kvStoreName\": \"boltdb\"\n  }\n}\n\n\n\nparam: indexType\n: required, string, form parameter\n\n\nSupported indexType's:\n\n\n\n\nalias\n: an alias provides a naming level of indirection to one or more actual, target indexes\n\n\nblackhole\n: a blackhole index ignores all data and is not queryable; used for testing\n\n\nbleve\n: a full-text index powered by the bleve engine\n\n\n\n\nparam: planParams\n: optional, string (JSON), form parameter\n\n\nparam: prevIndexUUID\n: optional, string, form parameter\n\n\nIntended for clients that want to check that they are not overwriting the index definition updates of concurrent clients.\n\n\nparam: sourceName\n: optional, string, form parameter\n\n\nparam: sourceParams\n: optional (depends on the value of the sourceType), string (JSON), form parameter\n\n\nFor sourceType \ncouchbase\n, an example sourceParams JSON:\n\n\n{\n  \"authUser\": \"\",\n  \"authPassword\": \"\",\n  \"authSaslUser\": \"\",\n  \"authSaslPassword\": \"\",\n  \"clusterManagerBackoffFactor\": 0,\n  \"clusterManagerSleepInitMS\": 0,\n  \"clusterManagerSleepMaxMS\": 20000,\n  \"dataManagerBackoffFactor\": 0,\n  \"dataManagerSleepInitMS\": 0,\n  \"dataManagerSleepMaxMS\": 20000,\n  \"feedBufferSizeBytes\": 0,\n  \"feedBufferAckThreshold\": 0\n}\n\n\n\nFor sourceType \nfiles\n, an example sourceParams JSON:\n\n\n{\n  \"regExps\": [\n    \".txt$\",\n    \".md$\"\n  ],\n  \"maxFileSize\": 0,\n  \"numPartitions\": 0,\n  \"sleepStartMS\": 5000,\n  \"backoffFactor\": 1.5,\n  \"maxSleepMS\": 300000\n}\n\n\n\nFor sourceType \nnil\n, the sourceParams can be null.\n\n\nparam: sourceType\n: required, string, form parameter\n\n\nSupported sourceType's:\n\n\n\n\ncouchbase\n: a Couchbase Server bucket will be the data source\n\n\nfiles\n: files under a dataDir subdirectory tree will be the data source\n\n\nnil\n: a nil data source has no data; used for index aliases and testing\n\n\n\n\nparam: sourceUUID\n: optional, string, form parameter\n\n\nresult on error\n: non-200 HTTP error code\n\n\nresult on success\n: HTTP 200 with body JSON of {\"status\": \"ok\"}\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nDELETE \n/api/index/{indexName}\n\n\nDeletes an index definition.\n\n\nparam: indexName\n: required, string, URL path parameter\n\n\nThe name of the index definition to be deleted.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nIndex management\n\n\n\n\nPOST \n/api/index/{indexName}/ingestControl/{op}\n\n\nPause index updates and maintenance (no more\n                          ingesting document mutations).\n\n\nparam: indexName\n: required, string, URL path parameter\n\n\nThe name of the index whose control values will be modified.\n\n\nparam: op\n: required, string, URL path parameter\n\n\nAllowed values for op are \"pause\" or \"resume\".\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nPOST \n/api/index/{indexName}/planFreezeControl/{op}\n\n\nFreeze the assignment of index partitions to nodes.\n\n\nparam: indexName\n: required, string, URL path parameter\n\n\nThe name of the index whose control values will be modified.\n\n\nparam: op\n: required, string, URL path parameter\n\n\nAllowed values for op are \"freeze\" or \"unfreeze\".\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nPOST \n/api/index/{indexName}/queryControl/{op}\n\n\nDisallow queries on an index.\n\n\nparam: indexName\n: required, string, URL path parameter\n\n\nThe name of the index whose control values will be modified.\n\n\nparam: op\n: required, string, URL path parameter\n\n\nAllowed values for op are \"allow\" or \"disallow\".\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nIndex monitoring\n\n\n\n\nGET \n/api/stats\n\n\nReturns indexing and data related metrics,\n                       timings and counters from the node as JSON.\n\n\nversion introduced\n: 0.0.1\n\n\nSample response:\n\n\n{\n  \"feeds\": {\n    \"myFirstIndex_6cc599ab7a85bf3b\": {}\n  },\n  \"manager\": {\n    \"TotCreateIndex\": 1,\n    \"TotCreateIndexOk\": 1,\n    \"TotDeleteIndex\": 0,\n    \"TotDeleteIndexOk\": 0,\n    \"TotIndexControl\": 0,\n    \"TotIndexControlOk\": 0,\n    \"TotJanitorClosePIndex\": 0,\n    \"TotJanitorKick\": 2,\n    \"TotJanitorKickErr\": 0,\n    \"TotJanitorKickOk\": 2,\n    \"TotJanitorKickStart\": 2,\n    \"TotJanitorNOOP\": 0,\n    \"TotJanitorNOOPOk\": 0,\n    \"TotJanitorRemovePIndex\": 0,\n    \"TotJanitorSubscriptionEvent\": 0,\n    \"TotJanitorUnknownErr\": 0,\n    \"TotKick\": 0,\n    \"TotPlannerKick\": 2,\n    \"TotPlannerKickChanged\": 1,\n    \"TotPlannerKickErr\": 0,\n    \"TotPlannerKickOk\": 2,\n    \"TotPlannerKickStart\": 2,\n    \"TotPlannerNOOP\": 0,\n    \"TotPlannerNOOPOk\": 0,\n    \"TotPlannerSubscriptionEvent\": 0,\n    \"TotPlannerUnknownErr\": 0,\n    \"TotSaveNodeDef\": 2,\n    \"TotSaveNodeDefGetErr\": 0,\n    \"TotSaveNodeDefOk\": 2,\n    \"TotSaveNodeDefSame\": 0,\n    \"TotSaveNodeDefSetErr\": 0\n  },\n  \"pindexes\": {\n    \"myFirstIndex_6cc599ab7a85bf3b_0\": null\n  }\n}\n\n\n\n\n\nGET \n/api/stats/index/{indexName}\n\n\nReturns metrics, timings and counters\n                       for a single index from the node as JSON.\n\n\nversion introduced\n: 0.0.1\n\n\nSample response:\n\n\n{\n  \"feeds\": {\n    \"myFirstIndex_6cc599ab7a85bf3b\": {}\n  },\n  \"pindexes\": {\n    \"myFirstIndex_6cc599ab7a85bf3b_0\": null\n  }\n}\n\n\n\n\n\nIndex querying\n\n\n\n\nGET \n/api/index/{indexName}/count\n\n\nReturns the count of indexed documents.\n\n\nparam: indexName\n: required, string, URL path parameter\n\n\nThe name of the index whose count is to be retrieved.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nPOST \n/api/index/{indexName}/query\n\n\nQueries an index.\n\n\nparam: indexName\n: required, string, URL path parameter\n\n\nThe name of the index to be queried.\n\n\nversion introduced\n: 0.2.0\n\n\nThe request's POST body depends on the index type:\n\n\nFor index type \nbleve\n:\n\n\nA simple bleve query POST body:\n\n\n{\n  \"query\": {\n    \"query\": \"a sample query\",\n    \"boost\": 1\n  },\n  \"size\": 10,\n  \"from\": 0,\n  \"highlight\": null,\n  \"fields\": null,\n  \"facets\": null,\n  \"explain\": false\n}\n\n\n\nAn example POST body using from/size for results paging,\nusing ctl for a timeout and for \"at_plus\" consistency level.\nOn consistency, the index must have incorporated at least mutation\nsequence-number 123 for partition (vbucket) 0 and mutation\nsequence-number 234 for partition (vbucket) 1 (where vbucket 1\nshould have a vbucketUUID of a0b1c2):\n\n\n{\n  \"ctl\": {\n    \"timeout\": 10000,\n    \"consistency\": {\n      \"level\": \"at_plus\",\n      \"vectors\": {\n        \"customerIndex\": {\n          \"0\": 123,\n          \"1/a0b1c2\": 234\n        }\n      }\n    }\n  },\n  \"query\": {\n    \"query\": \"alice smith\",\n    \"boost\": 1\n  },\n  \"size\": 10,\n  \"from\": 20,\n  \"highlight\": {\n    \"style\": null,\n    \"fields\": null\n  },\n  \"fields\": [\n    \"*\"\n  ],\n  \"facets\": null,\n  \"explain\": true\n}\n\n\n\n\n\nNode\n\n\n\n\nNode configuration\n\n\n\n\nGET \n/api/cfg\n\n\nReturns the node's current view\n                       of the cluster's configuration as JSON.\n\n\nversion introduced\n: 0.0.1\n\n\nSample response:\n\n\n{\n  \"indexDefs\": {\n    \"implVersion\": \"4.0.0\",\n    \"indexDefs\": {\n      \"myFirstIndex\": {\n        \"name\": \"myFirstIndex\",\n        \"params\": \"\",\n        \"planParams\": {\n          \"hierarchyRules\": null,\n          \"maxPartitionsPerPIndex\": 0,\n          \"nodePlanParams\": null,\n          \"numReplicas\": 0,\n          \"planFrozen\": false\n        },\n        \"sourceName\": \"\",\n        \"sourceParams\": \"\",\n        \"sourceType\": \"nil\",\n        \"sourceUUID\": \"\",\n        \"type\": \"blackhole\",\n        \"uuid\": \"6cc599ab7a85bf3b\"\n      }\n    },\n    \"uuid\": \"6cc599ab7a85bf3b\"\n  },\n  \"indexDefsCAS\": 3,\n  \"indexDefsErr\": null,\n  \"nodeDefsKnown\": {\n    \"implVersion\": \"4.0.0\",\n    \"nodeDefs\": {\n      \"78fc2ffac2fd9401\": {\n        \"container\": \"\",\n        \"extras\": \"\",\n        \"hostPort\": \"0.0.0.0:8095\",\n        \"implVersion\": \"4.0.0\",\n        \"tags\": null,\n        \"uuid\": \"78fc2ffac2fd9401\",\n        \"weight\": 1\n      }\n    },\n    \"uuid\": \"2f0d18fb750b2d4a\"\n  },\n  \"nodeDefsKnownCAS\": 1,\n  \"nodeDefsKnownErr\": null,\n  \"nodeDefsWanted\": {\n    \"implVersion\": \"4.0.0\",\n    \"nodeDefs\": {\n      \"78fc2ffac2fd9401\": {\n        \"container\": \"\",\n        \"extras\": \"\",\n        \"hostPort\": \"0.0.0.0:8095\",\n        \"implVersion\": \"4.0.0\",\n        \"tags\": null,\n        \"uuid\": \"78fc2ffac2fd9401\",\n        \"weight\": 1\n      }\n    },\n    \"uuid\": \"72d6750878551451\"\n  },\n  \"nodeDefsWantedCAS\": 2,\n  \"nodeDefsWantedErr\": null,\n  \"planPIndexes\": {\n    \"implVersion\": \"4.0.0\",\n    \"planPIndexes\": {\n      \"myFirstIndex_6cc599ab7a85bf3b_0\": {\n        \"indexName\": \"myFirstIndex\",\n        \"indexParams\": \"\",\n        \"indexType\": \"blackhole\",\n        \"indexUUID\": \"6cc599ab7a85bf3b\",\n        \"name\": \"myFirstIndex_6cc599ab7a85bf3b_0\",\n        \"nodes\": {\n          \"78fc2ffac2fd9401\": {\n            \"canRead\": true,\n            \"canWrite\": true,\n            \"priority\": 0\n          }\n        },\n        \"sourceName\": \"\",\n        \"sourceParams\": \"\",\n        \"sourcePartitions\": \"\",\n        \"sourceType\": \"nil\",\n        \"sourceUUID\": \"\",\n        \"uuid\": \"64bed6e2edf354c3\"\n      }\n    },\n    \"uuid\": \"6327debf817a5ec7\",\n    \"warnings\": {\n      \"myFirstIndex\": []\n    }\n  },\n  \"planPIndexesCAS\": 5,\n  \"planPIndexesErr\": null,\n  \"status\": \"ok\"\n}\n\n\n\n\n\nPOST \n/api/cfgRefresh\n\n\nRequests the node to refresh its configuration\n                       from the configuration provider.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nPOST \n/api/managerKick\n\n\nForces the node to replan resource assignments\n                       (by running the planner, if enabled) and to update\n                       its runtime state to reflect the latest plan\n                       (by running the janitor, if enabled).\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nGET \n/api/managerMeta\n\n\nReturns information on the node's capabilities,\n                       including available indexing and storage options as JSON,\n                       and is intended to help management tools and web UI's\n                       to be more dynamically metadata driven.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nNode diagnostics\n\n\n\n\nGET \n/api/diag\n\n\nReturns full set of diagnostic information\n                        from the node in one shot as JSON.  That is, the\n                        /api/diag response will be the union of the responses\n                        from the other REST API diagnostic and monitoring\n                        endpoints from the node, and is intended to make\n                        production support easier.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nGET \n/api/log\n\n\nReturns recent log messages\n                       and key events for the node as JSON.\n\n\nversion introduced\n: 0.0.1\n\n\nSample response:\n\n\n{\n  \"events\": [],\n  \"messages\": []\n}\n\n\n\n\n\nGET \n/api/runtime\n\n\nReturns information on the node's software,\n                       such as version strings and slow-changing\n                       runtime settings as JSON.\n\n\nversion introduced\n: 0.0.1\n\n\nSample response:\n\n\n{\n  \"arch\": \"amd64\",\n  \"go\": {\n    \"GOMAXPROCS\": 1,\n    \"GOROOT\": \"/usr/src/go\",\n    \"compiler\": \"gc\",\n    \"version\": \"go1.4.2\"\n  },\n  \"numCPU\": 8,\n  \"os\": \"linux\",\n  \"versionData\": \"4.0.0\",\n  \"versionMain\": \"v0.3.0\"\n}\n\n\n\n\n\nGET \n/api/runtime/args\n\n\nReturns information on the node's command-line,\n                       parameters, environment variables and\n                       O/S process values as JSON.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nPOST \n/api/runtime/profile/cpu\n\n\nRequests the node to capture local\n                       cpu usage profiling information.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nPOST \n/api/runtime/profile/memory\n\n\nRequests the node to capture lcoal\n                       memory usage profiling information.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nNode management\n\n\n\n\nPOST \n/api/runtime/gc\n\n\nRequests the node to perform a GC.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nNode monitoring\n\n\n\n\nGET \n/api/runtime/stats\n\n\nReturns information on the node's\n                       low-level runtime stats as JSON.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nGET \n/api/runtime/statsMem\n\n\nReturns information on the node's\n                       low-level GC and memory related runtime stats as JSON.\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nAdvanced\n\n\n\n\nIndex partition definition\n\n\n\n\nGET \n/api/pindex\n\n\nversion introduced\n: 0.0.1\n\n\nSample response:\n\n\n{\n  \"pindexes\": {\n    \"myFirstIndex_6cc599ab7a85bf3b_0\": {\n      \"indexName\": \"myFirstIndex\",\n      \"indexParams\": \"\",\n      \"indexType\": \"blackhole\",\n      \"indexUUID\": \"6cc599ab7a85bf3b\",\n      \"name\": \"myFirstIndex_6cc599ab7a85bf3b_0\",\n      \"sourceName\": \"\",\n      \"sourceParams\": \"\",\n      \"sourcePartitions\": \"\",\n      \"sourceType\": \"nil\",\n      \"sourceUUID\": \"\",\n      \"uuid\": \"2d9ecb8b574a9f6a\"\n    }\n  },\n  \"status\": \"ok\"\n}\n\n\n\n\n\nGET \n/api/pindex/{pindexName}\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nIndex partition querying\n\n\n\n\nGET \n/api/pindex/{pindexName}/count\n\n\nversion introduced\n: 0.0.1\n\n\n\n\nPOST \n/api/pindex/{pindexName}/query\n\n\nversion introduced\n: 0.2.0\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "API Reference"
        }, 
        {
            "location": "/api-ref/#api-reference", 
            "text": "", 
            "title": "API Reference"
        }, 
        {
            "location": "/api-ref/#indexing", 
            "text": "", 
            "title": "Indexing"
        }, 
        {
            "location": "/api-ref/#index-definition", 
            "text": "GET  /api/index  Returns all index definitions as JSON.  version introduced : 0.0.1  Sample response:  {\n  \"indexDefs\": {\n    \"implVersion\": \"4.0.0\",\n    \"indexDefs\": {\n      \"myFirstIndex\": {\n        \"name\": \"myFirstIndex\",\n        \"params\": \"\",\n        \"planParams\": {\n          \"hierarchyRules\": null,\n          \"maxPartitionsPerPIndex\": 0,\n          \"nodePlanParams\": null,\n          \"numReplicas\": 0,\n          \"planFrozen\": false\n        },\n        \"sourceName\": \"\",\n        \"sourceParams\": \"\",\n        \"sourceType\": \"nil\",\n        \"sourceUUID\": \"\",\n        \"type\": \"blackhole\",\n        \"uuid\": \"6cc599ab7a85bf3b\"\n      }\n    },\n    \"uuid\": \"6cc599ab7a85bf3b\"\n  },\n  \"status\": \"ok\"\n}   GET  /api/index/{indexName}  Returns the definition of an index as JSON.  param: indexName : required, string, URL path parameter  The name of the index definition to be retrieved.  version introduced : 0.0.1  Sample response:  {\n  \"indexDef\": {\n    \"name\": \"myFirstIndex\",\n    \"params\": \"\",\n    \"planParams\": {\n      \"hierarchyRules\": null,\n      \"maxPartitionsPerPIndex\": 0,\n      \"nodePlanParams\": null,\n      \"numReplicas\": 0,\n      \"planFrozen\": false\n    },\n    \"sourceName\": \"\",\n    \"sourceParams\": \"\",\n    \"sourceType\": \"nil\",\n    \"sourceUUID\": \"\",\n    \"type\": \"blackhole\",\n    \"uuid\": \"6cc599ab7a85bf3b\"\n  },\n  \"planPIndexes\": [\n    {\n      \"indexName\": \"myFirstIndex\",\n      \"indexParams\": \"\",\n      \"indexType\": \"blackhole\",\n      \"indexUUID\": \"6cc599ab7a85bf3b\",\n      \"name\": \"myFirstIndex_6cc599ab7a85bf3b_0\",\n      \"nodes\": {\n        \"78fc2ffac2fd9401\": {\n          \"canRead\": true,\n          \"canWrite\": true,\n          \"priority\": 0\n        }\n      },\n      \"sourceName\": \"\",\n      \"sourceParams\": \"\",\n      \"sourcePartitions\": \"\",\n      \"sourceType\": \"nil\",\n      \"sourceUUID\": \"\",\n      \"uuid\": \"64bed6e2edf354c3\"\n    }\n  ],\n  \"status\": \"ok\",\n  \"warnings\": []\n}   PUT  /api/index/{indexName}  Creates/updates an index definition.  param: indexName : required, string, URL path parameter  The name of the to-be-created/updated index definition,\nvalidated with the regular expression of  ^[A-Za-z][0-9A-Za-z_\\-]*$ .  param: indexParams : optional (depends on the value of the indexType), string (JSON), form parameter  For indexType  alias , an example indexParams JSON:  {\n  \"targets\": {\n    \"yourIndexName\": {\n      \"indexUUID\": \"\"\n    }\n  }\n}  For indexType  blackhole , the indexParams can be null.  For indexType  bleve , an example indexParams JSON:  {\n  \"mapping\": {\n    \"default_mapping\": {\n      \"enabled\": true,\n      \"dynamic\": true,\n      \"default_analyzer\": \"\"\n    },\n    \"type_field\": \"_type\",\n    \"default_type\": \"_default\",\n    \"default_analyzer\": \"standard\",\n    \"default_datetime_parser\": \"dateTimeOptional\",\n    \"default_field\": \"_all\",\n    \"byte_array_converter\": \"json\",\n    \"analysis\": {}\n  },\n  \"store\": {\n    \"kvStoreName\": \"boltdb\"\n  }\n}  param: indexType : required, string, form parameter  Supported indexType's:   alias : an alias provides a naming level of indirection to one or more actual, target indexes  blackhole : a blackhole index ignores all data and is not queryable; used for testing  bleve : a full-text index powered by the bleve engine   param: planParams : optional, string (JSON), form parameter  param: prevIndexUUID : optional, string, form parameter  Intended for clients that want to check that they are not overwriting the index definition updates of concurrent clients.  param: sourceName : optional, string, form parameter  param: sourceParams : optional (depends on the value of the sourceType), string (JSON), form parameter  For sourceType  couchbase , an example sourceParams JSON:  {\n  \"authUser\": \"\",\n  \"authPassword\": \"\",\n  \"authSaslUser\": \"\",\n  \"authSaslPassword\": \"\",\n  \"clusterManagerBackoffFactor\": 0,\n  \"clusterManagerSleepInitMS\": 0,\n  \"clusterManagerSleepMaxMS\": 20000,\n  \"dataManagerBackoffFactor\": 0,\n  \"dataManagerSleepInitMS\": 0,\n  \"dataManagerSleepMaxMS\": 20000,\n  \"feedBufferSizeBytes\": 0,\n  \"feedBufferAckThreshold\": 0\n}  For sourceType  files , an example sourceParams JSON:  {\n  \"regExps\": [\n    \".txt$\",\n    \".md$\"\n  ],\n  \"maxFileSize\": 0,\n  \"numPartitions\": 0,\n  \"sleepStartMS\": 5000,\n  \"backoffFactor\": 1.5,\n  \"maxSleepMS\": 300000\n}  For sourceType  nil , the sourceParams can be null.  param: sourceType : required, string, form parameter  Supported sourceType's:   couchbase : a Couchbase Server bucket will be the data source  files : files under a dataDir subdirectory tree will be the data source  nil : a nil data source has no data; used for index aliases and testing   param: sourceUUID : optional, string, form parameter  result on error : non-200 HTTP error code  result on success : HTTP 200 with body JSON of {\"status\": \"ok\"}  version introduced : 0.0.1   DELETE  /api/index/{indexName}  Deletes an index definition.  param: indexName : required, string, URL path parameter  The name of the index definition to be deleted.  version introduced : 0.0.1", 
            "title": "Index definition"
        }, 
        {
            "location": "/api-ref/#index-management", 
            "text": "POST  /api/index/{indexName}/ingestControl/{op}  Pause index updates and maintenance (no more\n                          ingesting document mutations).  param: indexName : required, string, URL path parameter  The name of the index whose control values will be modified.  param: op : required, string, URL path parameter  Allowed values for op are \"pause\" or \"resume\".  version introduced : 0.0.1   POST  /api/index/{indexName}/planFreezeControl/{op}  Freeze the assignment of index partitions to nodes.  param: indexName : required, string, URL path parameter  The name of the index whose control values will be modified.  param: op : required, string, URL path parameter  Allowed values for op are \"freeze\" or \"unfreeze\".  version introduced : 0.0.1   POST  /api/index/{indexName}/queryControl/{op}  Disallow queries on an index.  param: indexName : required, string, URL path parameter  The name of the index whose control values will be modified.  param: op : required, string, URL path parameter  Allowed values for op are \"allow\" or \"disallow\".  version introduced : 0.0.1", 
            "title": "Index management"
        }, 
        {
            "location": "/api-ref/#index-monitoring", 
            "text": "GET  /api/stats  Returns indexing and data related metrics,\n                       timings and counters from the node as JSON.  version introduced : 0.0.1  Sample response:  {\n  \"feeds\": {\n    \"myFirstIndex_6cc599ab7a85bf3b\": {}\n  },\n  \"manager\": {\n    \"TotCreateIndex\": 1,\n    \"TotCreateIndexOk\": 1,\n    \"TotDeleteIndex\": 0,\n    \"TotDeleteIndexOk\": 0,\n    \"TotIndexControl\": 0,\n    \"TotIndexControlOk\": 0,\n    \"TotJanitorClosePIndex\": 0,\n    \"TotJanitorKick\": 2,\n    \"TotJanitorKickErr\": 0,\n    \"TotJanitorKickOk\": 2,\n    \"TotJanitorKickStart\": 2,\n    \"TotJanitorNOOP\": 0,\n    \"TotJanitorNOOPOk\": 0,\n    \"TotJanitorRemovePIndex\": 0,\n    \"TotJanitorSubscriptionEvent\": 0,\n    \"TotJanitorUnknownErr\": 0,\n    \"TotKick\": 0,\n    \"TotPlannerKick\": 2,\n    \"TotPlannerKickChanged\": 1,\n    \"TotPlannerKickErr\": 0,\n    \"TotPlannerKickOk\": 2,\n    \"TotPlannerKickStart\": 2,\n    \"TotPlannerNOOP\": 0,\n    \"TotPlannerNOOPOk\": 0,\n    \"TotPlannerSubscriptionEvent\": 0,\n    \"TotPlannerUnknownErr\": 0,\n    \"TotSaveNodeDef\": 2,\n    \"TotSaveNodeDefGetErr\": 0,\n    \"TotSaveNodeDefOk\": 2,\n    \"TotSaveNodeDefSame\": 0,\n    \"TotSaveNodeDefSetErr\": 0\n  },\n  \"pindexes\": {\n    \"myFirstIndex_6cc599ab7a85bf3b_0\": null\n  }\n}   GET  /api/stats/index/{indexName}  Returns metrics, timings and counters\n                       for a single index from the node as JSON.  version introduced : 0.0.1  Sample response:  {\n  \"feeds\": {\n    \"myFirstIndex_6cc599ab7a85bf3b\": {}\n  },\n  \"pindexes\": {\n    \"myFirstIndex_6cc599ab7a85bf3b_0\": null\n  }\n}", 
            "title": "Index monitoring"
        }, 
        {
            "location": "/api-ref/#index-querying", 
            "text": "GET  /api/index/{indexName}/count  Returns the count of indexed documents.  param: indexName : required, string, URL path parameter  The name of the index whose count is to be retrieved.  version introduced : 0.0.1   POST  /api/index/{indexName}/query  Queries an index.  param: indexName : required, string, URL path parameter  The name of the index to be queried.  version introduced : 0.2.0  The request's POST body depends on the index type:  For index type  bleve :  A simple bleve query POST body:  {\n  \"query\": {\n    \"query\": \"a sample query\",\n    \"boost\": 1\n  },\n  \"size\": 10,\n  \"from\": 0,\n  \"highlight\": null,\n  \"fields\": null,\n  \"facets\": null,\n  \"explain\": false\n}  An example POST body using from/size for results paging,\nusing ctl for a timeout and for \"at_plus\" consistency level.\nOn consistency, the index must have incorporated at least mutation\nsequence-number 123 for partition (vbucket) 0 and mutation\nsequence-number 234 for partition (vbucket) 1 (where vbucket 1\nshould have a vbucketUUID of a0b1c2):  {\n  \"ctl\": {\n    \"timeout\": 10000,\n    \"consistency\": {\n      \"level\": \"at_plus\",\n      \"vectors\": {\n        \"customerIndex\": {\n          \"0\": 123,\n          \"1/a0b1c2\": 234\n        }\n      }\n    }\n  },\n  \"query\": {\n    \"query\": \"alice smith\",\n    \"boost\": 1\n  },\n  \"size\": 10,\n  \"from\": 20,\n  \"highlight\": {\n    \"style\": null,\n    \"fields\": null\n  },\n  \"fields\": [\n    \"*\"\n  ],\n  \"facets\": null,\n  \"explain\": true\n}", 
            "title": "Index querying"
        }, 
        {
            "location": "/api-ref/#node", 
            "text": "", 
            "title": "Node"
        }, 
        {
            "location": "/api-ref/#node-configuration", 
            "text": "GET  /api/cfg  Returns the node's current view\n                       of the cluster's configuration as JSON.  version introduced : 0.0.1  Sample response:  {\n  \"indexDefs\": {\n    \"implVersion\": \"4.0.0\",\n    \"indexDefs\": {\n      \"myFirstIndex\": {\n        \"name\": \"myFirstIndex\",\n        \"params\": \"\",\n        \"planParams\": {\n          \"hierarchyRules\": null,\n          \"maxPartitionsPerPIndex\": 0,\n          \"nodePlanParams\": null,\n          \"numReplicas\": 0,\n          \"planFrozen\": false\n        },\n        \"sourceName\": \"\",\n        \"sourceParams\": \"\",\n        \"sourceType\": \"nil\",\n        \"sourceUUID\": \"\",\n        \"type\": \"blackhole\",\n        \"uuid\": \"6cc599ab7a85bf3b\"\n      }\n    },\n    \"uuid\": \"6cc599ab7a85bf3b\"\n  },\n  \"indexDefsCAS\": 3,\n  \"indexDefsErr\": null,\n  \"nodeDefsKnown\": {\n    \"implVersion\": \"4.0.0\",\n    \"nodeDefs\": {\n      \"78fc2ffac2fd9401\": {\n        \"container\": \"\",\n        \"extras\": \"\",\n        \"hostPort\": \"0.0.0.0:8095\",\n        \"implVersion\": \"4.0.0\",\n        \"tags\": null,\n        \"uuid\": \"78fc2ffac2fd9401\",\n        \"weight\": 1\n      }\n    },\n    \"uuid\": \"2f0d18fb750b2d4a\"\n  },\n  \"nodeDefsKnownCAS\": 1,\n  \"nodeDefsKnownErr\": null,\n  \"nodeDefsWanted\": {\n    \"implVersion\": \"4.0.0\",\n    \"nodeDefs\": {\n      \"78fc2ffac2fd9401\": {\n        \"container\": \"\",\n        \"extras\": \"\",\n        \"hostPort\": \"0.0.0.0:8095\",\n        \"implVersion\": \"4.0.0\",\n        \"tags\": null,\n        \"uuid\": \"78fc2ffac2fd9401\",\n        \"weight\": 1\n      }\n    },\n    \"uuid\": \"72d6750878551451\"\n  },\n  \"nodeDefsWantedCAS\": 2,\n  \"nodeDefsWantedErr\": null,\n  \"planPIndexes\": {\n    \"implVersion\": \"4.0.0\",\n    \"planPIndexes\": {\n      \"myFirstIndex_6cc599ab7a85bf3b_0\": {\n        \"indexName\": \"myFirstIndex\",\n        \"indexParams\": \"\",\n        \"indexType\": \"blackhole\",\n        \"indexUUID\": \"6cc599ab7a85bf3b\",\n        \"name\": \"myFirstIndex_6cc599ab7a85bf3b_0\",\n        \"nodes\": {\n          \"78fc2ffac2fd9401\": {\n            \"canRead\": true,\n            \"canWrite\": true,\n            \"priority\": 0\n          }\n        },\n        \"sourceName\": \"\",\n        \"sourceParams\": \"\",\n        \"sourcePartitions\": \"\",\n        \"sourceType\": \"nil\",\n        \"sourceUUID\": \"\",\n        \"uuid\": \"64bed6e2edf354c3\"\n      }\n    },\n    \"uuid\": \"6327debf817a5ec7\",\n    \"warnings\": {\n      \"myFirstIndex\": []\n    }\n  },\n  \"planPIndexesCAS\": 5,\n  \"planPIndexesErr\": null,\n  \"status\": \"ok\"\n}   POST  /api/cfgRefresh  Requests the node to refresh its configuration\n                       from the configuration provider.  version introduced : 0.0.1   POST  /api/managerKick  Forces the node to replan resource assignments\n                       (by running the planner, if enabled) and to update\n                       its runtime state to reflect the latest plan\n                       (by running the janitor, if enabled).  version introduced : 0.0.1   GET  /api/managerMeta  Returns information on the node's capabilities,\n                       including available indexing and storage options as JSON,\n                       and is intended to help management tools and web UI's\n                       to be more dynamically metadata driven.  version introduced : 0.0.1", 
            "title": "Node configuration"
        }, 
        {
            "location": "/api-ref/#node-diagnostics", 
            "text": "GET  /api/diag  Returns full set of diagnostic information\n                        from the node in one shot as JSON.  That is, the\n                        /api/diag response will be the union of the responses\n                        from the other REST API diagnostic and monitoring\n                        endpoints from the node, and is intended to make\n                        production support easier.  version introduced : 0.0.1   GET  /api/log  Returns recent log messages\n                       and key events for the node as JSON.  version introduced : 0.0.1  Sample response:  {\n  \"events\": [],\n  \"messages\": []\n}   GET  /api/runtime  Returns information on the node's software,\n                       such as version strings and slow-changing\n                       runtime settings as JSON.  version introduced : 0.0.1  Sample response:  {\n  \"arch\": \"amd64\",\n  \"go\": {\n    \"GOMAXPROCS\": 1,\n    \"GOROOT\": \"/usr/src/go\",\n    \"compiler\": \"gc\",\n    \"version\": \"go1.4.2\"\n  },\n  \"numCPU\": 8,\n  \"os\": \"linux\",\n  \"versionData\": \"4.0.0\",\n  \"versionMain\": \"v0.3.0\"\n}   GET  /api/runtime/args  Returns information on the node's command-line,\n                       parameters, environment variables and\n                       O/S process values as JSON.  version introduced : 0.0.1   POST  /api/runtime/profile/cpu  Requests the node to capture local\n                       cpu usage profiling information.  version introduced : 0.0.1   POST  /api/runtime/profile/memory  Requests the node to capture lcoal\n                       memory usage profiling information.  version introduced : 0.0.1", 
            "title": "Node diagnostics"
        }, 
        {
            "location": "/api-ref/#node-management", 
            "text": "POST  /api/runtime/gc  Requests the node to perform a GC.  version introduced : 0.0.1", 
            "title": "Node management"
        }, 
        {
            "location": "/api-ref/#node-monitoring", 
            "text": "GET  /api/runtime/stats  Returns information on the node's\n                       low-level runtime stats as JSON.  version introduced : 0.0.1   GET  /api/runtime/statsMem  Returns information on the node's\n                       low-level GC and memory related runtime stats as JSON.  version introduced : 0.0.1", 
            "title": "Node monitoring"
        }, 
        {
            "location": "/api-ref/#advanced", 
            "text": "", 
            "title": "Advanced"
        }, 
        {
            "location": "/api-ref/#index-partition-definition", 
            "text": "GET  /api/pindex  version introduced : 0.0.1  Sample response:  {\n  \"pindexes\": {\n    \"myFirstIndex_6cc599ab7a85bf3b_0\": {\n      \"indexName\": \"myFirstIndex\",\n      \"indexParams\": \"\",\n      \"indexType\": \"blackhole\",\n      \"indexUUID\": \"6cc599ab7a85bf3b\",\n      \"name\": \"myFirstIndex_6cc599ab7a85bf3b_0\",\n      \"sourceName\": \"\",\n      \"sourceParams\": \"\",\n      \"sourcePartitions\": \"\",\n      \"sourceType\": \"nil\",\n      \"sourceUUID\": \"\",\n      \"uuid\": \"2d9ecb8b574a9f6a\"\n    }\n  },\n  \"status\": \"ok\"\n}   GET  /api/pindex/{pindexName}  version introduced : 0.0.1", 
            "title": "Index partition definition"
        }, 
        {
            "location": "/api-ref/#index-partition-querying", 
            "text": "GET  /api/pindex/{pindexName}/count  version introduced : 0.0.1   POST  /api/pindex/{pindexName}/query  version introduced : 0.2.0   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Index partition querying"
        }, 
        {
            "location": "/admin-guide/overview/", 
            "text": "Administrator's guide\n\n\nThe administrator's guide has the following sections...\n\n\n\n\ncbft command-line\n - usage help for cbft's command-line parameters\n\n\nPlanning your deployment\n - things to consider when planning a cbft cluster\n\n\nRunning cbft\n - information on starting a cbft node\n\n\nClustering cbft\n - information on clustering multiple cbft nodes together\n\n\nManaging cbft\n - information on mangaging indexes and nodes\n\n\nMonitoring cbft\n - details on stats and logs for monitoring a cbft cluster and nodes\n\n\nDiagnosing issues\n - considerations when things go wrong\n\n\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Administrator's guide overview"
        }, 
        {
            "location": "/admin-guide/overview/#administrators-guide", 
            "text": "The administrator's guide has the following sections...   cbft command-line  - usage help for cbft's command-line parameters  Planning your deployment  - things to consider when planning a cbft cluster  Running cbft  - information on starting a cbft node  Clustering cbft  - information on clustering multiple cbft nodes together  Managing cbft  - information on mangaging indexes and nodes  Monitoring cbft  - details on stats and logs for monitoring a cbft cluster and nodes  Diagnosing issues  - considerations when things go wrong    Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Administrator's guide"
        }, 
        {
            "location": "/admin-guide/command/", 
            "text": "cbft command-line\n\n\nCommand-line help is available by running...\n\n\n./cbft --help\n\n\n\nThat will print out usage/help output...\n\n\nsh: 1: ./cbft: not found\n\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "cbft command-line"
        }, 
        {
            "location": "/admin-guide/command/#cbft-command-line", 
            "text": "Command-line help is available by running...  ./cbft --help  That will print out usage/help output...  sh: 1: ./cbft: not found   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "cbft command-line"
        }, 
        {
            "location": "/admin-guide/planning/", 
            "text": "Planning your deployment\n\n\nThis document provides considerations on how a cbft deployment might\nbe planned, across different environments and application lifecycle\nstages:\n\n\n\n\nfrom development\n\n\nto staging/test\n\n\nand to production\n\n\n\n\nDevelopment\n\n\nDevelopers are expected to likely run cbft in \"single node\" fashion or\nin non-clustered \nsimple\n mode, directly on their personal development\nworkstations or laptop machines.\n\n\nDevelopers can write applications which query their single, local cbft\nnode using their favorite web-stack technologies and REST client\nsoftware to access their cbft node.\n\n\nSimilar to how developers would have separate scripts to initialize a\ndatabase with tables or buckets or schemas -- the so-called \"DDL\"\n(data definition language) instructions of \"CREATE TABLE...\" / \"CREATE\nINDEX...\", it is expected that developers would also code up separate\nscripts to create cbft index definitions.\n\n\nThese index definition scripts would then often be checked into the\napplication's source code control systems (e.g., like svn or git or\nmercurial or equivalent), for repeatability and for sharability with\ncolleagues.\n\n\ncbft is designed so that index defintions which developers define and\ncreate on their local, personal development workstations or laptops\ncan be deployed to production clusters without any changes to\napplication code that depends on those indexes.\n\n\nStaging and test\n\n\nTesting engineers would likely use the index definition scripts\nprovided by application developers in order to setup and configure\ntheir testing and staging cbft clusters.\n\n\nThe testing/staging cbft clusters would also be a good place to\nreconfirm any sizing and performance assumptions.  For example,\nperhaps an updated index definition utilizes new features of the\n\nbleve\n full-text engine, but those new features require more\nresources (cpu, memory, storage) and these changes would ideally need\nto be accounted for and reconfirmed before \"going live\" with\nproduction changes.\n\n\nProduction\n\n\nDeployment of index definitions or updated index definitions to\nproduction clusters would ideally follow the same steps that were\ntested in testing/staging cbft clusters.\n\n\nOne useful technique to increase availability would be to utilize\ncbft's index alias feature to allow for updated indexes to be be built\nup in the background without affecting existing application queries.\n\n\nApplications would still continue to query, by using index aliases, to\nprevious index definitions.  When the new index definitions are\nfinally built up enough and ready for querying, an administrator would\nthen redefine their index aliases to point at their newly ready target\nindex definitions.\n\n\nAdditional reading\n\n\nTradeoffs and considerations to \nincreasing index\nperformance\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Planning your deployment"
        }, 
        {
            "location": "/admin-guide/planning/#planning-your-deployment", 
            "text": "This document provides considerations on how a cbft deployment might\nbe planned, across different environments and application lifecycle\nstages:   from development  to staging/test  and to production", 
            "title": "Planning your deployment"
        }, 
        {
            "location": "/admin-guide/planning/#development", 
            "text": "Developers are expected to likely run cbft in \"single node\" fashion or\nin non-clustered  simple  mode, directly on their personal development\nworkstations or laptop machines.  Developers can write applications which query their single, local cbft\nnode using their favorite web-stack technologies and REST client\nsoftware to access their cbft node.  Similar to how developers would have separate scripts to initialize a\ndatabase with tables or buckets or schemas -- the so-called \"DDL\"\n(data definition language) instructions of \"CREATE TABLE...\" / \"CREATE\nINDEX...\", it is expected that developers would also code up separate\nscripts to create cbft index definitions.  These index definition scripts would then often be checked into the\napplication's source code control systems (e.g., like svn or git or\nmercurial or equivalent), for repeatability and for sharability with\ncolleagues.  cbft is designed so that index defintions which developers define and\ncreate on their local, personal development workstations or laptops\ncan be deployed to production clusters without any changes to\napplication code that depends on those indexes.  Staging and test  Testing engineers would likely use the index definition scripts\nprovided by application developers in order to setup and configure\ntheir testing and staging cbft clusters.  The testing/staging cbft clusters would also be a good place to\nreconfirm any sizing and performance assumptions.  For example,\nperhaps an updated index definition utilizes new features of the bleve  full-text engine, but those new features require more\nresources (cpu, memory, storage) and these changes would ideally need\nto be accounted for and reconfirmed before \"going live\" with\nproduction changes.  Production  Deployment of index definitions or updated index definitions to\nproduction clusters would ideally follow the same steps that were\ntested in testing/staging cbft clusters.  One useful technique to increase availability would be to utilize\ncbft's index alias feature to allow for updated indexes to be be built\nup in the background without affecting existing application queries.  Applications would still continue to query, by using index aliases, to\nprevious index definitions.  When the new index definitions are\nfinally built up enough and ready for querying, an administrator would\nthen redefine their index aliases to point at their newly ready target\nindex definitions.", 
            "title": "Development"
        }, 
        {
            "location": "/admin-guide/planning/#additional-reading", 
            "text": "Tradeoffs and considerations to  increasing index\nperformance   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Additional reading"
        }, 
        {
            "location": "/admin-guide/running/", 
            "text": "Running cbft\n\n\nThe \ngetting started\n guide provides a basic introduction\nto starting cbft.\n\n\nThis document provides information on some additional considerations.\n\n\ncbft dependencies\n\n\nThe cbft program executable is designed to be a single, standalone,\nself-sufficient binary image and should not require additional shared\nlibraries or pre-installed dependencies.\n\n\nData directory\n\n\ncbft requires a data directory where it can store and maintain local\nconfiguration data and index data.\n\n\nThis data directory path is defined by the \ndataDir\n command-line\nparameter.\n\n\nIf a \ndataDir\n is not specified, cbft will create a \"data\"\ndirectory in its current working directory for its data directory.\n\n\nAdvanced users may wish to have a separate filesystem which can handle\nlarger data volumes and high storage I/O performance.\n\n\nUsers running in cloud-based environments may wish to consider\nnon-ephemeral, mounted block stores, such as EBS (Elastic Block Store)\non Amazon Web Services EC2 systems or equivalent for your cloud\nhosting provider.\n\n\nIn a container-based environment, such as Docker or equivalent, users\nshould consider a non-ephemeral, high performance host volume for\ntheir cbft \ndataDir\n data directory.\n\n\nNode UUID\n\n\nAn important file stored in the data directory is the \ncbft.uuid\n\nfile.\n\n\nThe \ncbft.uuid\n file records the \nNode UUID\n of the cbft node,\nwhich is a unique, persistent identifier for a cbft node that is\ncritical for clustering multiple cbft nodes together.\n\n\nThe \ncbft.uuid\n file must remain the same and readable across\nrestarts of the cbft process for cbft clustering to work properly.\n\n\nThe first time a cbft is started, with an empty data directory, cbft\nwill detect that the \ncbft.uuid\n file does not exist and will\ngenerate a new node UUID and save it to a new \ncbft.uuid\n file.\n\n\nOn a restart of the cbft node, the cbft node must find the same\n\ncbft.uuid\n file in order to have the same node UUID across\nprocess restarts.\n\n\nIf you move the data directory (e.g., such as to move the data\ndirectory a storage volume with more available storage space or higher\nperformance) be sure to also move/copy over the \ncbft.uuid\n file.\n\n\nBindHttp / Port numbers\n\n\ncbft provides a HTTP/REST API endpoint, listening on the address:port\nspecified by the \nbindHttp\n command-line parameter.\n\n\nThe default value for \nbindHttp\n is \"0.0.0.0:8095\", so the default\nbind address is 0.0.0.0 and default port number is 8095.\n\n\nFor example:\n\n\n./cbft -bindHttp=0.0.0.0:8095 -server=http://cb-01:8091\n\n\n\nFor clustering and for remote application/client accessibility, you\nmust specify an actual IP address instead of the \"0.0.0.0\" (and also\nnot use \"127.0.0.1\"), as that supplied IP address will be used by\nother cbft nodes and client applications to contact your cbft node.\n\n\nFor example, if your IP address is \"10.1.1.10\", then:\n\n\n./cbft -bindHttp=10.1.1.10:8095 -server=http://cb-01:8091 \\\n       -cfg=couchbase:http://cfg-bucket@cb-01:8091\n\n\n\nThe port number (e.g., 8095) must also be enabled on your firewall\nsystems, if any, to allow remote access.\n\n\nEach cbft node in a cbft cluster can have its own, different port\nnumber.\n\n\nMultiple cbft nodes can be run on a single machine and clustered\ntoegther, by giving each cbft node its own unique port number.  This\ncan be useful for testing.\n\n\nSecuring cbft\n\n\nWARNING / TODO: cbft Developer Preview release currently does not\nprovide security features (e.g., encryption, authentication).\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Running cbft"
        }, 
        {
            "location": "/admin-guide/running/#running-cbft", 
            "text": "The  getting started  guide provides a basic introduction\nto starting cbft.  This document provides information on some additional considerations.", 
            "title": "Running cbft"
        }, 
        {
            "location": "/admin-guide/running/#cbft-dependencies", 
            "text": "The cbft program executable is designed to be a single, standalone,\nself-sufficient binary image and should not require additional shared\nlibraries or pre-installed dependencies.", 
            "title": "cbft dependencies"
        }, 
        {
            "location": "/admin-guide/running/#data-directory", 
            "text": "cbft requires a data directory where it can store and maintain local\nconfiguration data and index data.  This data directory path is defined by the  dataDir  command-line\nparameter.  If a  dataDir  is not specified, cbft will create a \"data\"\ndirectory in its current working directory for its data directory.  Advanced users may wish to have a separate filesystem which can handle\nlarger data volumes and high storage I/O performance.  Users running in cloud-based environments may wish to consider\nnon-ephemeral, mounted block stores, such as EBS (Elastic Block Store)\non Amazon Web Services EC2 systems or equivalent for your cloud\nhosting provider.  In a container-based environment, such as Docker or equivalent, users\nshould consider a non-ephemeral, high performance host volume for\ntheir cbft  dataDir  data directory.", 
            "title": "Data directory"
        }, 
        {
            "location": "/admin-guide/running/#node-uuid", 
            "text": "An important file stored in the data directory is the  cbft.uuid \nfile.  The  cbft.uuid  file records the  Node UUID  of the cbft node,\nwhich is a unique, persistent identifier for a cbft node that is\ncritical for clustering multiple cbft nodes together.  The  cbft.uuid  file must remain the same and readable across\nrestarts of the cbft process for cbft clustering to work properly.  The first time a cbft is started, with an empty data directory, cbft\nwill detect that the  cbft.uuid  file does not exist and will\ngenerate a new node UUID and save it to a new  cbft.uuid  file.  On a restart of the cbft node, the cbft node must find the same cbft.uuid  file in order to have the same node UUID across\nprocess restarts.  If you move the data directory (e.g., such as to move the data\ndirectory a storage volume with more available storage space or higher\nperformance) be sure to also move/copy over the  cbft.uuid  file.", 
            "title": "Node UUID"
        }, 
        {
            "location": "/admin-guide/running/#bindhttp-port-numbers", 
            "text": "cbft provides a HTTP/REST API endpoint, listening on the address:port\nspecified by the  bindHttp  command-line parameter.  The default value for  bindHttp  is \"0.0.0.0:8095\", so the default\nbind address is 0.0.0.0 and default port number is 8095.  For example:  ./cbft -bindHttp=0.0.0.0:8095 -server=http://cb-01:8091  For clustering and for remote application/client accessibility, you\nmust specify an actual IP address instead of the \"0.0.0.0\" (and also\nnot use \"127.0.0.1\"), as that supplied IP address will be used by\nother cbft nodes and client applications to contact your cbft node.  For example, if your IP address is \"10.1.1.10\", then:  ./cbft -bindHttp=10.1.1.10:8095 -server=http://cb-01:8091 \\\n       -cfg=couchbase:http://cfg-bucket@cb-01:8091  The port number (e.g., 8095) must also be enabled on your firewall\nsystems, if any, to allow remote access.  Each cbft node in a cbft cluster can have its own, different port\nnumber.  Multiple cbft nodes can be run on a single machine and clustered\ntoegther, by giving each cbft node its own unique port number.  This\ncan be useful for testing.", 
            "title": "BindHttp / Port numbers"
        }, 
        {
            "location": "/admin-guide/running/#securing-cbft", 
            "text": "WARNING / TODO: cbft Developer Preview release currently does not\nprovide security features (e.g., encryption, authentication).   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Securing cbft"
        }, 
        {
            "location": "/admin-guide/clustering/", 
            "text": "Clustering cbft\n\n\nTo run multiple cbft nodes in a cluster, you need to use a Cfg\nprovider that supports clustering.\n\n\nOf note: the default \nsimple\n Cfg provider that often used for\ndeveloper environments is local-only and does not support clustering.\n\n\nSetting up a Couchbase Cfg provider\n\n\nThe \ncouchbase\n Cfg provider supports clustering.\n\n\nThe \ncouchbase\n Cfg provider uses a Couchbase bucket to store\ncbft's configuration data.\n\n\nThe configuration data that will be stored by cbft in the Cfg provider\nis JSON data that includes your index definitions, index partition\ninformation, and information on the cbft nodes that are part of the\ncluster.\n\n\nMultiple cbft nodes that are all pointed to the same Couchbase bucket\nas a Cfg provider will use that Couchbase bucket to coordinate and\nrendevous on cbft's configuration data.\n\n\nTo use the \ncouchbase\n Cfg provider:\n\n\n\n\n\n\nPick a name for the Couchbase bucket that will be used to store cbft\n  cluster configuration data.  For example, \ncfg-bucket\n.\n\n\n\n\n\n\nUsing Couchbase's web UI or tools, create the \ncfg-bucket\n\n  bucket in Couchbase.\n\n\n\n\n\n\nChoose the smallest memory resource quota for the \ncfg-bucket\n\n  (e.g., 100MB RAM).  The amount of configuration data that will be\n  stored in the \ncfg-bucket\n by cbft will be very small, even for\n  large cbft cluster sizes.\n\n\n\n\n\n\nNext, start cbft with the \ncouchbase\n Cfg provider, pointed at\n  the \ncfg-bucket\n.\n\n\n\n\n\n\nFor example...\n\n\n./cbft -cfg=couchbase:http://cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -bindHttp=10.1.1.10:8095\n\n\n\nThe bindHttp address and port\n\n\nYou must specify an actual, valid IP address for the \nbindHttp\n\ncommand-line parameter for clustering to work.\n\n\nThe IP address allows application clients and peer cbft nodes to\ncontact the cbft node using the provided \nbindHttp\n IP address.\n\n\nEach node in the cbft cluster should have its own, unique\n\nbindHttp\n address and port.\n\n\nBy actual, valid IP address, you may not use \"0.0.0.0\" or \"127.0.0.1\".\n\n\nAdditionally, any firewall on the machine, if any, should be\nconfigured to allow for remote access through the \nbindHttp\n's IP\naddress and port.\n\n\nAdding cbft nodes\n\n\nOn a different machine, you can next start a second cbft node, pointed\nat the same, shared \ncfg-bucket\n...\n\n\n./cbft -cfg=couchbase:http://cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -bindHttp=10.1.1.11:8095\n\n\n\nSince these two cbft nodes are using the same \ncfg-bucket\n as\ntheir Cfg provider (\"http://cfg-bucket@couchbase-01:8091\"), these two\ncbft nodes are now clustered.\n\n\nA cluster running on a single machine\n\n\nAdditionally, you can run another cbft node on the same machine, but\nspecify a different, unique \nbindHttp\n port number and\n\ndataDir\n for each cbft node.  For example:\n\n\nmkdir -p /data/cbft-9090\nmkdir -p /data/cbft-9091\nmkdir -p /data/cbft-9092\n\n\n\nThen run the following three commands on the same machine, each in its\nown terminal or shell session:\n\n\n./cbft -cfg=couchbase:http://my-cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -dataDir=/data/cbft-9090 \\\n       -bindHttp=10.1.1.10:9090\n\n./cbft -cfg=couchbase:http://my-cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -dataDir=/data/cbft-9091 \\\n       -bindHttp=10.1.1.10:9091\n\n./cbft -cfg=couchbase:http://my-cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -dataDir=/data/cbft-9092 \\\n       -bindHttp=10.1.1.10:9092\n\n\n\nThe above will result in a three node cbft cluster all running on the\nsame machine.\n\n\nThis can be usefule for testing and for experimenting with cbft\ncluster capabilities and behavior, without the cost of needing\nactual, multiple machines.\n\n\nAvailability of the Cfg provider\n\n\nIf the Couchbase cluster that powers the \ncfg-bucket\n becomes\nunavailable, then the cbft nodes will continue to run and service\nquery requests, but you will not be able to make any cbft cluster\nconfiguration changes (modify index definitions or add/remove cbft\nnodes) until the Couchbase cluster returns to online, normal running\nhealth.\n\n\nThe cbft nodes will independently, repeatedly (with some delay between\nretries) try to reconnect back to the Couchbase \ncfg-bucket\n until\nit becomes available again.\n\n\nRelated, if the Couchbase \ncfg-bucket\n is accidentally deleted,\nthe cbft nodes will also continue to independently run and service\nquery requests, but you will also not be able to make any cbft cluster\nconfiguration changes (modify index definitions or add/remove cbft\nnodes).\n\n\nAdditionally, if the Couchbase \ncfg-bucket\n is deleted and\nrecreated (so ends up in blank, new, empty state, or was flush'ed),\nthe cbft nodes will also reset to an empty, brand new cbft cluster\nwithout any indexes defined.\n\n\nPut another way, the Couchbase bucket (\ncfg-bucket\n) is considered\nthe \nsource of truth\n for the cbft cluster's configuration and is a\nkey platform dependency of the cbft cluster.\n\n\nAdministrators should backup the Couchbase \ncfg-bucket\n to ensure\ntheir ability to restore services.  And, any application scripts to\nrecreate index definitions can also be used to restore index\ndefinitions in situations of disaster recovery.\n\n\ncbft node states\n\n\nEach cbft node is registered into the cbft cluster with a node state.\n\n\nThe node states:\n\n\n\n\nwanted\n: a cbft node in wanted state is expected to be part of\n  the cluster and will have index partitions automatically assigned to\n  it.\n\n\n\n\nIf a cbft node in wanted state temporarily disappears (e.g. the\nmachine's rebooted), the cbft node will not lose its previous index\npartition assignments, but will be expected to come back online soon\n(machine reboot and/or process restart) so that the cbft node will\ncontinue to serviceits previously assigned index partitions.\n\n\nThis design approach is because a cbft node might have a large amount\nof persistent index data that can be inefficient for other cbft nodes\nto rebuild from scratch, in contrast to just waiting a bit for a node\nto restart.\n\n\nThat is, having index partition assignments \"bounce around\" and be\nquickly reassigned amongst different cbft nodes could lead to wasteful\nthrashing of resources.\n\n\n\n\n\n\nknown\n: a cbft node in known state is listed in the cluster,\n  but will not be assigned any index partitions.\n\n\n\n\n\n\nunknown\n: this is a node that is not part of the cluster, is\n  not actually listed in cbft's cluster configuration data, and will\n  not be assigned any index partitions.\n\n\n\n\n\n\nRemoving cbft nodes\n\n\nTo remove a cbft node from a cluster, you need to have its registered\nstate changed to \nunknown\n.  To do so, if you had a cbft node\nrunning previously as...\n\n\n./cbft -cfg=couchbase:http://my-cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -dataDir=/data/cbft-9090 \\\n       -bindHttp=10.1.1.10:9090\n\n\n\n\n\n\n\nFirst, stop the cbft node process (e.g., kill the cbft process).\n\n\n\n\n\n\nThen, run the cbft node with the same exact command-line, but with\n  the additional command-line parameter of \n--register=unknown\n.\n\n\n\n\n\n\nFor example...\n\n\n./cbft -cfg=couchbase:http://my-cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -dataDir=/data/cbft-9090 \\\n       -bindHttp=10.1.1.10:9090 \\\n       -register=unknown\n\n\n\nThe key to removing a node with the \n--register=unknown\n\ncommand-line parameter is that your cbft invocation must have the\nsame, exact \n-bindHttp\n parameter, \n-cfg\n parameter, and node\nUUID (stored previously in the \ndataDir\n as the \ncbft.uuid\n\nfile)\n\n\nThat will move that cbft node into \nunknown\n state in the cluster,\nand any of that cbft node's previously assigned index partitions will\nbe re-assigned to other, remaining wanted cbft nodes in the cluster.\n\n\nNode identity\n\n\nThe cbft node's UUID and bindHttp (address:port) values must be unique\nfor a new cbft node to join a cluster.\n\n\nPlease see the administrator's guide on \nrunning cbft\n for\nmore information on the node UUID and bindHTTP values.\n\n\nIndex replicas\n\n\nOnce you have more than one cbft node in a cluster, then you can\nleverage cbft's index replica features.\n\n\nIndex replicas are additional copies of index partitions assigned to\nmore than one node and are built up by just re-indexing the data again\nfrom the original data source on a different cbft node.\n\n\nThat is, the extra copies of index partitions are not built via chain\nreplication (A -\n X -\n Y) but are instead built via star replication\n(A -\n X; A -\n Y).\n\n\nTo enable replicas for an index, you need to set the \nnumReplicas\n\nconfiguration field for an index definition to greater than 0.  Please\nsee \nnumReplicas\n documentation in the developer's guide on \nindex\ndefinitions\n for more information.\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Clustering cbft"
        }, 
        {
            "location": "/admin-guide/clustering/#clustering-cbft", 
            "text": "To run multiple cbft nodes in a cluster, you need to use a Cfg\nprovider that supports clustering.  Of note: the default  simple  Cfg provider that often used for\ndeveloper environments is local-only and does not support clustering.", 
            "title": "Clustering cbft"
        }, 
        {
            "location": "/admin-guide/clustering/#setting-up-a-couchbase-cfg-provider", 
            "text": "The  couchbase  Cfg provider supports clustering.  The  couchbase  Cfg provider uses a Couchbase bucket to store\ncbft's configuration data.  The configuration data that will be stored by cbft in the Cfg provider\nis JSON data that includes your index definitions, index partition\ninformation, and information on the cbft nodes that are part of the\ncluster.  Multiple cbft nodes that are all pointed to the same Couchbase bucket\nas a Cfg provider will use that Couchbase bucket to coordinate and\nrendevous on cbft's configuration data.  To use the  couchbase  Cfg provider:    Pick a name for the Couchbase bucket that will be used to store cbft\n  cluster configuration data.  For example,  cfg-bucket .    Using Couchbase's web UI or tools, create the  cfg-bucket \n  bucket in Couchbase.    Choose the smallest memory resource quota for the  cfg-bucket \n  (e.g., 100MB RAM).  The amount of configuration data that will be\n  stored in the  cfg-bucket  by cbft will be very small, even for\n  large cbft cluster sizes.    Next, start cbft with the  couchbase  Cfg provider, pointed at\n  the  cfg-bucket .    For example...  ./cbft -cfg=couchbase:http://cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -bindHttp=10.1.1.10:8095", 
            "title": "Setting up a Couchbase Cfg provider"
        }, 
        {
            "location": "/admin-guide/clustering/#the-bindhttp-address-and-port", 
            "text": "You must specify an actual, valid IP address for the  bindHttp \ncommand-line parameter for clustering to work.  The IP address allows application clients and peer cbft nodes to\ncontact the cbft node using the provided  bindHttp  IP address.  Each node in the cbft cluster should have its own, unique bindHttp  address and port.  By actual, valid IP address, you may not use \"0.0.0.0\" or \"127.0.0.1\".  Additionally, any firewall on the machine, if any, should be\nconfigured to allow for remote access through the  bindHttp 's IP\naddress and port.", 
            "title": "The bindHttp address and port"
        }, 
        {
            "location": "/admin-guide/clustering/#adding-cbft-nodes", 
            "text": "On a different machine, you can next start a second cbft node, pointed\nat the same, shared  cfg-bucket ...  ./cbft -cfg=couchbase:http://cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -bindHttp=10.1.1.11:8095  Since these two cbft nodes are using the same  cfg-bucket  as\ntheir Cfg provider (\"http://cfg-bucket@couchbase-01:8091\"), these two\ncbft nodes are now clustered.", 
            "title": "Adding cbft nodes"
        }, 
        {
            "location": "/admin-guide/clustering/#a-cluster-running-on-a-single-machine", 
            "text": "Additionally, you can run another cbft node on the same machine, but\nspecify a different, unique  bindHttp  port number and dataDir  for each cbft node.  For example:  mkdir -p /data/cbft-9090\nmkdir -p /data/cbft-9091\nmkdir -p /data/cbft-9092  Then run the following three commands on the same machine, each in its\nown terminal or shell session:  ./cbft -cfg=couchbase:http://my-cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -dataDir=/data/cbft-9090 \\\n       -bindHttp=10.1.1.10:9090\n\n./cbft -cfg=couchbase:http://my-cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -dataDir=/data/cbft-9091 \\\n       -bindHttp=10.1.1.10:9091\n\n./cbft -cfg=couchbase:http://my-cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -dataDir=/data/cbft-9092 \\\n       -bindHttp=10.1.1.10:9092  The above will result in a three node cbft cluster all running on the\nsame machine.  This can be usefule for testing and for experimenting with cbft\ncluster capabilities and behavior, without the cost of needing\nactual, multiple machines.", 
            "title": "A cluster running on a single machine"
        }, 
        {
            "location": "/admin-guide/clustering/#availability-of-the-cfg-provider", 
            "text": "If the Couchbase cluster that powers the  cfg-bucket  becomes\nunavailable, then the cbft nodes will continue to run and service\nquery requests, but you will not be able to make any cbft cluster\nconfiguration changes (modify index definitions or add/remove cbft\nnodes) until the Couchbase cluster returns to online, normal running\nhealth.  The cbft nodes will independently, repeatedly (with some delay between\nretries) try to reconnect back to the Couchbase  cfg-bucket  until\nit becomes available again.  Related, if the Couchbase  cfg-bucket  is accidentally deleted,\nthe cbft nodes will also continue to independently run and service\nquery requests, but you will also not be able to make any cbft cluster\nconfiguration changes (modify index definitions or add/remove cbft\nnodes).  Additionally, if the Couchbase  cfg-bucket  is deleted and\nrecreated (so ends up in blank, new, empty state, or was flush'ed),\nthe cbft nodes will also reset to an empty, brand new cbft cluster\nwithout any indexes defined.  Put another way, the Couchbase bucket ( cfg-bucket ) is considered\nthe  source of truth  for the cbft cluster's configuration and is a\nkey platform dependency of the cbft cluster.  Administrators should backup the Couchbase  cfg-bucket  to ensure\ntheir ability to restore services.  And, any application scripts to\nrecreate index definitions can also be used to restore index\ndefinitions in situations of disaster recovery.", 
            "title": "Availability of the Cfg provider"
        }, 
        {
            "location": "/admin-guide/clustering/#cbft-node-states", 
            "text": "Each cbft node is registered into the cbft cluster with a node state.  The node states:   wanted : a cbft node in wanted state is expected to be part of\n  the cluster and will have index partitions automatically assigned to\n  it.   If a cbft node in wanted state temporarily disappears (e.g. the\nmachine's rebooted), the cbft node will not lose its previous index\npartition assignments, but will be expected to come back online soon\n(machine reboot and/or process restart) so that the cbft node will\ncontinue to serviceits previously assigned index partitions.  This design approach is because a cbft node might have a large amount\nof persistent index data that can be inefficient for other cbft nodes\nto rebuild from scratch, in contrast to just waiting a bit for a node\nto restart.  That is, having index partition assignments \"bounce around\" and be\nquickly reassigned amongst different cbft nodes could lead to wasteful\nthrashing of resources.    known : a cbft node in known state is listed in the cluster,\n  but will not be assigned any index partitions.    unknown : this is a node that is not part of the cluster, is\n  not actually listed in cbft's cluster configuration data, and will\n  not be assigned any index partitions.", 
            "title": "cbft node states"
        }, 
        {
            "location": "/admin-guide/clustering/#removing-cbft-nodes", 
            "text": "To remove a cbft node from a cluster, you need to have its registered\nstate changed to  unknown .  To do so, if you had a cbft node\nrunning previously as...  ./cbft -cfg=couchbase:http://my-cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -dataDir=/data/cbft-9090 \\\n       -bindHttp=10.1.1.10:9090    First, stop the cbft node process (e.g., kill the cbft process).    Then, run the cbft node with the same exact command-line, but with\n  the additional command-line parameter of  --register=unknown .    For example...  ./cbft -cfg=couchbase:http://my-cfg-bucket@couchbase-01:8091 \\\n       -server=http://couchbase-01:8091 \\\n       -dataDir=/data/cbft-9090 \\\n       -bindHttp=10.1.1.10:9090 \\\n       -register=unknown  The key to removing a node with the  --register=unknown \ncommand-line parameter is that your cbft invocation must have the\nsame, exact  -bindHttp  parameter,  -cfg  parameter, and node\nUUID (stored previously in the  dataDir  as the  cbft.uuid \nfile)  That will move that cbft node into  unknown  state in the cluster,\nand any of that cbft node's previously assigned index partitions will\nbe re-assigned to other, remaining wanted cbft nodes in the cluster.", 
            "title": "Removing cbft nodes"
        }, 
        {
            "location": "/admin-guide/clustering/#node-identity", 
            "text": "The cbft node's UUID and bindHttp (address:port) values must be unique\nfor a new cbft node to join a cluster.  Please see the administrator's guide on  running cbft  for\nmore information on the node UUID and bindHTTP values.", 
            "title": "Node identity"
        }, 
        {
            "location": "/admin-guide/clustering/#index-replicas", 
            "text": "Once you have more than one cbft node in a cluster, then you can\nleverage cbft's index replica features.  Index replicas are additional copies of index partitions assigned to\nmore than one node and are built up by just re-indexing the data again\nfrom the original data source on a different cbft node.  That is, the extra copies of index partitions are not built via chain\nreplication (A -  X -  Y) but are instead built via star replication\n(A -  X; A -  Y).  To enable replicas for an index, you need to set the  numReplicas \nconfiguration field for an index definition to greater than 0.  Please\nsee  numReplicas  documentation in the developer's guide on  index\ndefinitions  for more information.   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Index replicas"
        }, 
        {
            "location": "/admin-guide/managing/", 
            "text": "Managing cbft\n\n\nThis document talks about the \"levers and toggles\" available to manage\ncbft indexes and cbft nodes.\n\n\nManaging cbft indexes\n\n\nIndex building\n\n\nIndex building is the process by which cbft sets up connections to\ndata sources, retrieves data from the data sources, analyzes that\ndata, and updates index data in memory and in persisted storage, in\nconcurrent fashion.\n\n\nBy concurrent, we mean that cbft uses internal pipelines or data\nstreams, as opposed to, for example, completely retrieving all the\ndata from a data source as one phase before starting any analysis\nphase.  Instead, cbft's approach allows for incremental processing,\nwhich is suited to also handle updates or mutations of data from the\ndata source over time.\n\n\ncbft will automatically start its concurrent index building steps as\nsoon as you create an index.\n\n\nDuring the index building phase, the index is queryable.  However,\ncbft may not have processed or ingested all the data for the index, of\ncourse, from its data source yet.  In this case, queries will return\nresponses for the data so far incorporated in a \"best effort\" fashion.\n\n\nIf a cbft node has to restart in the midst of index building, the\nrestarted cbft will attempt to \"pick up where it left off\" on its\nindexing activites, as much as possible and if the data source allows\nfor restartability of data streams.\n\n\nThe \ncouchbase\n data source type, of note, allows for\nrestartability of data streams.\n\n\nRebuilding indexes\n\n\nSometimes, an administrator wishes to rebuild an index from scratch,\nor as is sometimes described, \"rebuilding an index from zero\" or \"from\nscratch\" (in reference to an empty start condition and/or to a 0\nsequence number or very beginning of a sequence of data).\n\n\nTo rebuild an index from scratch in cbft, using your web browser in\nthe web admin UI:\n\n\n\n\n\n\nNavgiate to the \nIndexes\n page.\n\n\n\n\n\n\nFind the row for the index you wish to rebuild.\n\n\n\n\n\n\nOn that same row, click on the \nedit\n button, where you'll next\n  see an edit form for your index definition.\n\n\n\n\n\n\nOptional: you can make changes to your index definition at this\n  point, but you do not need to do just to get a rebuild.\n\n\n\n\n\n\nClick on the \nUpdate Index\n button at the bottom of the form.\n\n\n\n\n\n\nYour index will start rebuilding from scratch or from zero.\n\n\n\n\n\n\nIf you had made changes to your index definition, your new index\n  will reflect your index definition changes.\n\n\n\n\n\n\nOf note, the index UUID will change as part of this operation, which\nallows applications to detect that the index definition has \"changed\".\nThis may be important for some applications that are caching results,\netc.\n\n\nDisabling/enabling indexing\n\n\nSometimes, an administrator needs to pause index maintenance or\ningest.  For example, perhaps during key hours of heavy traffic, the\nadministrator would like to dedicate more resources to query\nperformance, at the cost of an out of date index.\n\n\nTo pause index ingest activities, in the web admin UI:\n\n\n\n\n\n\nNavigate to the \nIndexes\n page.\n\n\n\n\n\n\nClick on the index name link for the index whose ingest you wish to\n  pause.\n\n\n\n\n\n\nClick on the \nManage\n tab for your index.\n\n\n\n\n\n\nClick \nDisable Ingest\n button.\n\n\n\n\n\n\nThe \nIndex Ingest\n state will turn from \nenabled\n to\n\ndisabled\n, and the button you just clicked will turn into an\n\nEnable Ingest\n button.\n\n\nTo re-enable index processing and data ingest:\n\n\n\n\nClick on the \nEnable Ingest\n button.\n\n\n\n\nNote: if index ingest is disabled or paused, and your application is\nquerying the index and is specifying optional consistency parameters\n(it is trying to \"read its own writes\") those queries will be paused\nuntil the index ingest is re-enabled and the index has ingested all\nthe data up to the required consistency point.  This can lead to\napparently slow application behavior and application timeouts.\n\n\nDisabling/enabling queries\n\n\nSometimes, an administrator needs to temporarily disable the ability\nfor applications to make queries on an index.  For example, perhaps\nduring some 2:00AM hours of maintenance time, the administrator would\nlike the index ingest to \"catch up\" to the most recent data source\nmutations.\n\n\nOr perhaps, the administrator would like to rebuild indexes from\nscratch at this point.\n\n\nIn any case, by disabling queries, the administrator can help ensure\nmore resources will be used for index ingest processing.  That is, a\nslow, massive query might take resources away from the main priority\nof getting the index up to date, so pausing index query'ability can be\na useful feature.\n\n\nTo disable index query'ability, in the web admin UI:\n\n\n\n\n\n\nNavigate to the \nIndexes\n page.\n\n\n\n\n\n\nClick on the index name link for the index whose querying you wish\n  to disable.\n\n\n\n\n\n\nClick on the \nManage\n tab for your index.\n\n\n\n\n\n\nClick \nDisable Queries\n button.\n\n\n\n\n\n\nThe \nIndex Queries\n state will turn from \nenabled\n to\n\ndisabled\n, and the button you just clicked will turn into an\n\nEnable Queries\n button.\n\n\nAt this time, applications sending new query requests for your index\nwill receive error responses.\n\n\nTo re-enable queries on your index:\n\n\n\n\nClick on the \nEnable Queries\n button.\n\n\n\n\nDisabling/enabling partition reassignments\n\n\nNormally, as cbft nodes are added or removed from a cbft cluster, the\ncbft system automatically rebalances and reassigns index partitions to\nthe remaining nodes in the cluster.\n\n\nSometimes, an administrator needs to disable this automatic index\npartition reassignment, on a per index basis, because reassigned index\npartitions need to go through index building, and any queries during\nan index rebuild will see only the responses for data that have been\nindexed so far.\n\n\nTo disable index parittion reassignments, in the web admin UI:\n\n\n\n\n\n\nNavigate to the \nIndexes\n page.\n\n\n\n\n\n\nClick on the index name link for the index whose index partitions\n  you wish to to have reassignments disabled.\n\n\n\n\n\n\nClick on the \nManage\n tab for your index.\n\n\n\n\n\n\nClick \nDisable Reassignments\n button.\n\n\n\n\n\n\nThe \nIndex Partition Reassignments\n state will turn from\n\nenabled\n to \ndisabled\n, and the button you just clicked will\nturn into an \nEnable Reassignments\n button.\n\n\nAt this time, any cluster membership changes (cbft nodes added or\nremoved) will not trigger an automatic index partitions reassignment\nfor your index.\n\n\nTo re-enable index partition reassignments on your index:\n\n\n\n\nClick on the \nEnable Reassignments\n button.\n\n\n\n\nIndex definition changes and zero downtime\n\n\nWhen an index definition is created or modified, cbft will rebuild the\n index from scratch, starting from an empty state for that index.\n\n\nDuring that time, queries against a modified index can see \"missing\"\nresults, as an index rebuild can take time to ingest or process data\nfrom the data source.\n\n\nTo alleviate this situation and have \"zero downtime\" with respect to\nquery'ability, a user can utilize cbft's index alias feature.\n\n\nThe idea is to leverage the level of indirection in naming that an\nalias provides, where an application sends its queries to an index\nalias instead of directly to real indexes.\n\n\nAs an example, imagine the user creates a real index definition, such\nas for \nProductCatalogIndex-01\n.\n\n\nThen the user also creates an index alias, called\n\nProductCatalogAlias\n, which has \nProductCatalogIndex-01\n as\nits target.\n\n\nThe user's application is configured to make queries against\n\nProductCatalogAlias\n, and everything works fine.\n\n\nSome time later, however, the team discovers a need for additional\nfeatures, such as perhaps needing to adjust bleve's full-text\ntokenization configuration to improve its search results relevancy.\n\n\nRather than directly editing the \nProductCatalogIndex-01\n, instead\nthe team creates a brand new index, \nProductCatalogIndex-02\n,\nwhich has the improved index configuration.\n\n\nThe team lets \nProductCatalogIndex-02\n index build up to\nacceptable amount of data.\n\n\nThe team may also, optionally, wish to turn off indexing ingest for\n\nProductCatalogIndex-01\n, if application requirements allow for\nsome amount of stale'ness in indexes.\n\n\nWhen \nProductCatalogIndex-02\n is ready, the team edits the\n\nProductCatalogAlias\n definition to point to\n\nProductCatalogIndex-02\n instead of pointing to the previous\n\nProductCatalogIndex-01\n.\n\n\nThe application continues to query \nProductCatalogAlias\n with no\napparent downtime of queries.\n\n\nAs an advanced approach, the team may also allow some subset of the\napplication or subset of users (e.g., \"beta\" users) to instead query\nthe \nProductCatalogIndex-02\n, even while it is building up, in\norder to get a preview of the changed index configuration's behavior.\n\n\nThe resource cost of using an index alias for zero downtime to queries\nis double that of a single index, but some applications may have zero\ndowntime as a necessary requirement for production and are willing to\nbear the extra cost.\n\n\nNode/cluster changes and zero downtime\n\n\nSimilar to with handling index definition changes with zero downtime,\nan administrator can use index aliases in order to provide zero\ndowntime for application queries even as cluster membership changes\n(cbft nodes are added or removed).\n\n\nNormally, as nodes are added or removed from a cbft cluster (as\ndifferent cbft nodes are registered as wanted or unwanted or unknown),\nthe cbft system will automatically reassign index partitions amongst\nthe remaining nodes.  The reassigned index partitions need to be built\nup from scratch, however, which leads to queries not providing\nresponses to all data as the reassigned index partitions are being\nbuilt.\n\n\nThe solution is to use an index alias so that applications can\ncontinue to query the old index.\n\n\nAdditionally, \nbefore\n the administrator adds or removes nodes from a\ncbft cluster, the administrator should disable index partition\nreassignments for the current index definition.\n\n\nPlease see the instructions above for how to disable index partition\nreassignments for an index.\n\n\nThen, the administrator can add new cbft nodes, and the current index\ndefinition will remain \"stable\", where its index partitions will\nremain assigned to the set of old cbft nodes.\n\n\nThe administrator would next define a new index, where the index\npartitions of the new index would be assigned to both the old,\nremaining cbft nodes and also to the newly added cbft nodes.\n\n\nThe administrator would then monitor the cbft cluster, watching for\nindexing and ingest progress on the new index.\n\n\nWhen the new index has indexed or ingested enough data from the data\nsource, the administrator can then edit the index alias and repoint\nthe index alias away from the old index definition and instead point\nthe index alias to the new index definition.\n\n\nThen the administrator can delete the old index definition.\n\n\nThis operation allows applications to query the index alias with no\nloss of indexed data, but at the cost of requiring twice the resources\nto temporarily support two indexes in a cluster.\n\n\nAdvanced storage options\n\n\nTBD\n\n\nCompacting data\n\n\nTBD\n\n\nBackup and restore\n\n\ncbft includes various REST API endpoints to be able request the cbft\ncluster's current configuration and index definitions, which can be\nused for restoration purposes.\n\n\nThe Cfg provider (i.e., a Couchbase \nmy-cfg-bucket\n) should also\nhave replication enabled and be backed up for production usage.\n\n\nBecause cbft is used as an indexing server, the index data entries\nmaintained by cbft should also be able to be rebuilt \"from scratch\",\nat the cost of rebuild time, from the original \"source of truth\" data\nsources.\n\n\nAt root, though, the end-all/be-all safety net and recommended\npractice is that cbft index creation scripts should be checked into\nsource-code control systems so that any development, test or\nadministration colleagues on the application's team can replicate a\ncbft configuration at will.\n\n\nManaging cbft nodes\n\n\nWeb admin UI\n\n\nThe \nNodes\n screen in cbft's web admin UI shows a list of all the\ncbft nodes in a cbft cluster.\n\n\nDetailed information with you click on any particular cbft node link\nincludes:\n\n\n\n\n\n\nthe cbft node's version number\n\n\n\n\n\n\nthe cbft node's UUID or \ncbft.uuid\n\n\n\n\n\n\nthe cbft node's tags (e.g., such as whether the node is just a\n  \nqueryer\n)\n\n\n\n\n\n\nthe cbft node's container path for shelf/rack/row/zone/DC awareness\n\n\n\n\n\n\nthe cbft node's weight, to allow more powerful servers to service\n  more load\n\n\n\n\n\n\nForcing a manager kick\n\n\nA button to \nKick Manager\n is available in the web admin UI, on\nthe \nManage\n page.  Clicking it forces the cbft node to re-run its\nmanagement activities, which include re-partitioning indexes into\nindex partitions and re-assigning index partitions to nodes in the\ncluster.\n\n\nOf note, if the nodes and index definitions in a cluster have not\nchanged, then the re-paritioning and re-assignment activities of a\nmanager kick should result in the exact same \"plan\"; hence, a manager\nkick in that case would result effectively with nothing changing.\n\n\nAn optional \nKick Message\n input field allows the user to provide\ntext that will be logged by the cbft node, so that an administrator\ncan correlate manager kick requests with server-side logs.\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Managing cbft"
        }, 
        {
            "location": "/admin-guide/managing/#managing-cbft", 
            "text": "This document talks about the \"levers and toggles\" available to manage\ncbft indexes and cbft nodes.", 
            "title": "Managing cbft"
        }, 
        {
            "location": "/admin-guide/managing/#managing-cbft-indexes", 
            "text": "", 
            "title": "Managing cbft indexes"
        }, 
        {
            "location": "/admin-guide/managing/#index-building", 
            "text": "Index building is the process by which cbft sets up connections to\ndata sources, retrieves data from the data sources, analyzes that\ndata, and updates index data in memory and in persisted storage, in\nconcurrent fashion.  By concurrent, we mean that cbft uses internal pipelines or data\nstreams, as opposed to, for example, completely retrieving all the\ndata from a data source as one phase before starting any analysis\nphase.  Instead, cbft's approach allows for incremental processing,\nwhich is suited to also handle updates or mutations of data from the\ndata source over time.  cbft will automatically start its concurrent index building steps as\nsoon as you create an index.  During the index building phase, the index is queryable.  However,\ncbft may not have processed or ingested all the data for the index, of\ncourse, from its data source yet.  In this case, queries will return\nresponses for the data so far incorporated in a \"best effort\" fashion.  If a cbft node has to restart in the midst of index building, the\nrestarted cbft will attempt to \"pick up where it left off\" on its\nindexing activites, as much as possible and if the data source allows\nfor restartability of data streams.  The  couchbase  data source type, of note, allows for\nrestartability of data streams.", 
            "title": "Index building"
        }, 
        {
            "location": "/admin-guide/managing/#rebuilding-indexes", 
            "text": "Sometimes, an administrator wishes to rebuild an index from scratch,\nor as is sometimes described, \"rebuilding an index from zero\" or \"from\nscratch\" (in reference to an empty start condition and/or to a 0\nsequence number or very beginning of a sequence of data).  To rebuild an index from scratch in cbft, using your web browser in\nthe web admin UI:    Navgiate to the  Indexes  page.    Find the row for the index you wish to rebuild.    On that same row, click on the  edit  button, where you'll next\n  see an edit form for your index definition.    Optional: you can make changes to your index definition at this\n  point, but you do not need to do just to get a rebuild.    Click on the  Update Index  button at the bottom of the form.    Your index will start rebuilding from scratch or from zero.    If you had made changes to your index definition, your new index\n  will reflect your index definition changes.    Of note, the index UUID will change as part of this operation, which\nallows applications to detect that the index definition has \"changed\".\nThis may be important for some applications that are caching results,\netc.", 
            "title": "Rebuilding indexes"
        }, 
        {
            "location": "/admin-guide/managing/#disablingenabling-indexing", 
            "text": "Sometimes, an administrator needs to pause index maintenance or\ningest.  For example, perhaps during key hours of heavy traffic, the\nadministrator would like to dedicate more resources to query\nperformance, at the cost of an out of date index.  To pause index ingest activities, in the web admin UI:    Navigate to the  Indexes  page.    Click on the index name link for the index whose ingest you wish to\n  pause.    Click on the  Manage  tab for your index.    Click  Disable Ingest  button.    The  Index Ingest  state will turn from  enabled  to disabled , and the button you just clicked will turn into an Enable Ingest  button.  To re-enable index processing and data ingest:   Click on the  Enable Ingest  button.   Note: if index ingest is disabled or paused, and your application is\nquerying the index and is specifying optional consistency parameters\n(it is trying to \"read its own writes\") those queries will be paused\nuntil the index ingest is re-enabled and the index has ingested all\nthe data up to the required consistency point.  This can lead to\napparently slow application behavior and application timeouts.", 
            "title": "Disabling/enabling indexing"
        }, 
        {
            "location": "/admin-guide/managing/#disablingenabling-queries", 
            "text": "Sometimes, an administrator needs to temporarily disable the ability\nfor applications to make queries on an index.  For example, perhaps\nduring some 2:00AM hours of maintenance time, the administrator would\nlike the index ingest to \"catch up\" to the most recent data source\nmutations.  Or perhaps, the administrator would like to rebuild indexes from\nscratch at this point.  In any case, by disabling queries, the administrator can help ensure\nmore resources will be used for index ingest processing.  That is, a\nslow, massive query might take resources away from the main priority\nof getting the index up to date, so pausing index query'ability can be\na useful feature.  To disable index query'ability, in the web admin UI:    Navigate to the  Indexes  page.    Click on the index name link for the index whose querying you wish\n  to disable.    Click on the  Manage  tab for your index.    Click  Disable Queries  button.    The  Index Queries  state will turn from  enabled  to disabled , and the button you just clicked will turn into an Enable Queries  button.  At this time, applications sending new query requests for your index\nwill receive error responses.  To re-enable queries on your index:   Click on the  Enable Queries  button.", 
            "title": "Disabling/enabling queries"
        }, 
        {
            "location": "/admin-guide/managing/#disablingenabling-partition-reassignments", 
            "text": "Normally, as cbft nodes are added or removed from a cbft cluster, the\ncbft system automatically rebalances and reassigns index partitions to\nthe remaining nodes in the cluster.  Sometimes, an administrator needs to disable this automatic index\npartition reassignment, on a per index basis, because reassigned index\npartitions need to go through index building, and any queries during\nan index rebuild will see only the responses for data that have been\nindexed so far.  To disable index parittion reassignments, in the web admin UI:    Navigate to the  Indexes  page.    Click on the index name link for the index whose index partitions\n  you wish to to have reassignments disabled.    Click on the  Manage  tab for your index.    Click  Disable Reassignments  button.    The  Index Partition Reassignments  state will turn from enabled  to  disabled , and the button you just clicked will\nturn into an  Enable Reassignments  button.  At this time, any cluster membership changes (cbft nodes added or\nremoved) will not trigger an automatic index partitions reassignment\nfor your index.  To re-enable index partition reassignments on your index:   Click on the  Enable Reassignments  button.", 
            "title": "Disabling/enabling partition reassignments"
        }, 
        {
            "location": "/admin-guide/managing/#index-definition-changes-and-zero-downtime", 
            "text": "When an index definition is created or modified, cbft will rebuild the\n index from scratch, starting from an empty state for that index.  During that time, queries against a modified index can see \"missing\"\nresults, as an index rebuild can take time to ingest or process data\nfrom the data source.  To alleviate this situation and have \"zero downtime\" with respect to\nquery'ability, a user can utilize cbft's index alias feature.  The idea is to leverage the level of indirection in naming that an\nalias provides, where an application sends its queries to an index\nalias instead of directly to real indexes.  As an example, imagine the user creates a real index definition, such\nas for  ProductCatalogIndex-01 .  Then the user also creates an index alias, called ProductCatalogAlias , which has  ProductCatalogIndex-01  as\nits target.  The user's application is configured to make queries against ProductCatalogAlias , and everything works fine.  Some time later, however, the team discovers a need for additional\nfeatures, such as perhaps needing to adjust bleve's full-text\ntokenization configuration to improve its search results relevancy.  Rather than directly editing the  ProductCatalogIndex-01 , instead\nthe team creates a brand new index,  ProductCatalogIndex-02 ,\nwhich has the improved index configuration.  The team lets  ProductCatalogIndex-02  index build up to\nacceptable amount of data.  The team may also, optionally, wish to turn off indexing ingest for ProductCatalogIndex-01 , if application requirements allow for\nsome amount of stale'ness in indexes.  When  ProductCatalogIndex-02  is ready, the team edits the ProductCatalogAlias  definition to point to ProductCatalogIndex-02  instead of pointing to the previous ProductCatalogIndex-01 .  The application continues to query  ProductCatalogAlias  with no\napparent downtime of queries.  As an advanced approach, the team may also allow some subset of the\napplication or subset of users (e.g., \"beta\" users) to instead query\nthe  ProductCatalogIndex-02 , even while it is building up, in\norder to get a preview of the changed index configuration's behavior.  The resource cost of using an index alias for zero downtime to queries\nis double that of a single index, but some applications may have zero\ndowntime as a necessary requirement for production and are willing to\nbear the extra cost.", 
            "title": "Index definition changes and zero downtime"
        }, 
        {
            "location": "/admin-guide/managing/#nodecluster-changes-and-zero-downtime", 
            "text": "Similar to with handling index definition changes with zero downtime,\nan administrator can use index aliases in order to provide zero\ndowntime for application queries even as cluster membership changes\n(cbft nodes are added or removed).  Normally, as nodes are added or removed from a cbft cluster (as\ndifferent cbft nodes are registered as wanted or unwanted or unknown),\nthe cbft system will automatically reassign index partitions amongst\nthe remaining nodes.  The reassigned index partitions need to be built\nup from scratch, however, which leads to queries not providing\nresponses to all data as the reassigned index partitions are being\nbuilt.  The solution is to use an index alias so that applications can\ncontinue to query the old index.  Additionally,  before  the administrator adds or removes nodes from a\ncbft cluster, the administrator should disable index partition\nreassignments for the current index definition.  Please see the instructions above for how to disable index partition\nreassignments for an index.  Then, the administrator can add new cbft nodes, and the current index\ndefinition will remain \"stable\", where its index partitions will\nremain assigned to the set of old cbft nodes.  The administrator would next define a new index, where the index\npartitions of the new index would be assigned to both the old,\nremaining cbft nodes and also to the newly added cbft nodes.  The administrator would then monitor the cbft cluster, watching for\nindexing and ingest progress on the new index.  When the new index has indexed or ingested enough data from the data\nsource, the administrator can then edit the index alias and repoint\nthe index alias away from the old index definition and instead point\nthe index alias to the new index definition.  Then the administrator can delete the old index definition.  This operation allows applications to query the index alias with no\nloss of indexed data, but at the cost of requiring twice the resources\nto temporarily support two indexes in a cluster.", 
            "title": "Node/cluster changes and zero downtime"
        }, 
        {
            "location": "/admin-guide/managing/#advanced-storage-options", 
            "text": "TBD", 
            "title": "Advanced storage options"
        }, 
        {
            "location": "/admin-guide/managing/#compacting-data", 
            "text": "TBD", 
            "title": "Compacting data"
        }, 
        {
            "location": "/admin-guide/managing/#backup-and-restore", 
            "text": "cbft includes various REST API endpoints to be able request the cbft\ncluster's current configuration and index definitions, which can be\nused for restoration purposes.  The Cfg provider (i.e., a Couchbase  my-cfg-bucket ) should also\nhave replication enabled and be backed up for production usage.  Because cbft is used as an indexing server, the index data entries\nmaintained by cbft should also be able to be rebuilt \"from scratch\",\nat the cost of rebuild time, from the original \"source of truth\" data\nsources.  At root, though, the end-all/be-all safety net and recommended\npractice is that cbft index creation scripts should be checked into\nsource-code control systems so that any development, test or\nadministration colleagues on the application's team can replicate a\ncbft configuration at will.", 
            "title": "Backup and restore"
        }, 
        {
            "location": "/admin-guide/managing/#managing-cbft-nodes", 
            "text": "", 
            "title": "Managing cbft nodes"
        }, 
        {
            "location": "/admin-guide/managing/#web-admin-ui", 
            "text": "The  Nodes  screen in cbft's web admin UI shows a list of all the\ncbft nodes in a cbft cluster.  Detailed information with you click on any particular cbft node link\nincludes:    the cbft node's version number    the cbft node's UUID or  cbft.uuid    the cbft node's tags (e.g., such as whether the node is just a\n   queryer )    the cbft node's container path for shelf/rack/row/zone/DC awareness    the cbft node's weight, to allow more powerful servers to service\n  more load", 
            "title": "Web admin UI"
        }, 
        {
            "location": "/admin-guide/managing/#forcing-a-manager-kick", 
            "text": "A button to  Kick Manager  is available in the web admin UI, on\nthe  Manage  page.  Clicking it forces the cbft node to re-run its\nmanagement activities, which include re-partitioning indexes into\nindex partitions and re-assigning index partitions to nodes in the\ncluster.  Of note, if the nodes and index definitions in a cluster have not\nchanged, then the re-paritioning and re-assignment activities of a\nmanager kick should result in the exact same \"plan\"; hence, a manager\nkick in that case would result effectively with nothing changing.  An optional  Kick Message  input field allows the user to provide\ntext that will be logged by the cbft node, so that an administrator\ncan correlate manager kick requests with server-side logs.   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Forcing a manager kick"
        }, 
        {
            "location": "/admin-guide/monitoring/", 
            "text": "Monitoring cbft\n\n\ncbft provides the following monitoring features:\n\n\nLogs\n\n\nThe web admin UI \nLogs\n screen shows the most recent 1000 log\nmessages for the cbft node.  It is a convenience feature so that an\nadministrator does not have to log into the machine to see recent\nlogs.\n\n\nNote: the \nLogs\n screen does not show cluster-wide logs, but only\nthe logs from the cbft node that the web browser is pointed at.\n\n\nRecommended practice: an administrator should consider capturing\ncbft's stdout/stderr output to rotated files or to a centralized log\nservice.\n\n\nNode monitoring\n\n\nThe web admin UI of cbft provides a \nMonitor\n screen that shows\nnode-related memory and GC (garbage collection utlization).\n\n\nNode index monitoring\n\n\nThe web admin UI provides a dropdown on the \nMonitor\n screen to\ncontrol graphs that can allow an administrator to focus in on the\nindex partition performance of the current cbft node.\n\n\nIndex partition specific graphs include:\n\n\n\n\nUpdates (count of updates)\n\n\nDeletes (count of deletes)\n\n\nAnalysis/Index Time\n\n\nSearches (count of searches)\n\n\nSearch Time\n\n\n\n\nThe web admin UI also includes more numeric, per index monitoring\nstatistics.  Using a web browser...\n\n\n\n\n\n\nNavigate to the \nIndexes\n screen.\n\n\n\n\n\n\nClick on the index name link of the index you're interested in.\n\n\n\n\n\n\nClick on the Monitor sub-tab to see per-index specific stats and\n  counters.\n\n\n\n\n\n\nThe displayed stats and counters are only for the current cbft node.\n\n\nThe \nRefresh\n button will request the latest information from the\ncurrent cbft node.\n\n\nSelecting the \nShow all stats\n checkbox will display even more\nstats and counters.\n\n\nBy default, aggregated stats across index partitions for the current\ncbft node are shown.\n\n\nSelecting the \nShow details and timings for each index partition\n\ncheckbox will display non-aggregated details from every index\npartition from the current cbft node.\n\n\nMemory\n\n\nTBD\n\n\nGC pauses\n\n\nTBD\n\n\nCPU\n\n\nTBD\n\n\nStorage\n\n\nTBD\n\n\nNetworking\n\n\nTBD\n\n\nPerformance\n\n\nTBD\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Monitoring cbft"
        }, 
        {
            "location": "/admin-guide/monitoring/#monitoring-cbft", 
            "text": "cbft provides the following monitoring features:", 
            "title": "Monitoring cbft"
        }, 
        {
            "location": "/admin-guide/monitoring/#logs", 
            "text": "The web admin UI  Logs  screen shows the most recent 1000 log\nmessages for the cbft node.  It is a convenience feature so that an\nadministrator does not have to log into the machine to see recent\nlogs.  Note: the  Logs  screen does not show cluster-wide logs, but only\nthe logs from the cbft node that the web browser is pointed at.  Recommended practice: an administrator should consider capturing\ncbft's stdout/stderr output to rotated files or to a centralized log\nservice.", 
            "title": "Logs"
        }, 
        {
            "location": "/admin-guide/monitoring/#node-monitoring", 
            "text": "The web admin UI of cbft provides a  Monitor  screen that shows\nnode-related memory and GC (garbage collection utlization).", 
            "title": "Node monitoring"
        }, 
        {
            "location": "/admin-guide/monitoring/#node-index-monitoring", 
            "text": "The web admin UI provides a dropdown on the  Monitor  screen to\ncontrol graphs that can allow an administrator to focus in on the\nindex partition performance of the current cbft node.  Index partition specific graphs include:   Updates (count of updates)  Deletes (count of deletes)  Analysis/Index Time  Searches (count of searches)  Search Time   The web admin UI also includes more numeric, per index monitoring\nstatistics.  Using a web browser...    Navigate to the  Indexes  screen.    Click on the index name link of the index you're interested in.    Click on the Monitor sub-tab to see per-index specific stats and\n  counters.    The displayed stats and counters are only for the current cbft node.  The  Refresh  button will request the latest information from the\ncurrent cbft node.  Selecting the  Show all stats  checkbox will display even more\nstats and counters.  By default, aggregated stats across index partitions for the current\ncbft node are shown.  Selecting the  Show details and timings for each index partition \ncheckbox will display non-aggregated details from every index\npartition from the current cbft node.", 
            "title": "Node index monitoring"
        }, 
        {
            "location": "/admin-guide/monitoring/#memory", 
            "text": "TBD  GC pauses  TBD", 
            "title": "Memory"
        }, 
        {
            "location": "/admin-guide/monitoring/#cpu", 
            "text": "TBD", 
            "title": "CPU"
        }, 
        {
            "location": "/admin-guide/monitoring/#storage", 
            "text": "TBD", 
            "title": "Storage"
        }, 
        {
            "location": "/admin-guide/monitoring/#networking", 
            "text": "TBD", 
            "title": "Networking"
        }, 
        {
            "location": "/admin-guide/monitoring/#performance", 
            "text": "TBD   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "Performance"
        }, 
        {
            "location": "/admin-guide/diagnosing/", 
            "text": "Diagnosing issues\n\n\ncbft includes several REST API endpoints to programatically gather\nstats, counters and health information as JSON responses.\n\n\nREST /api/diag\n\n\nA key REST API endpoint, however, is \n/api/diag\n, which will\ngather as much diagnosis information as possible about a cbft node to\nbe sent in a single JSON response.\n\n\nFor example, for a three node cluster, you could capture the\n\n/api/diag\n output of each node with something like:\n\n\ncurl http://cbft-01:8095/api/diag \n cbft-01.json\ncurl http://cbft-02:8095/api/diag \n cbft-02.json\ncurl http://cbft-03:8095/api/diag \n cbft-03.json\n\n\n\nThe \n/api/diag\n response can be a quite large JSON object (100's\nof KB and often much more).\n\n\nThe motivation with \n/api/diag\n is to simplify working with the\nCouchbase community, forums, technical support and other engineers by\nmaking data capture from each cbft node easy in one shot.\n\n\nTBD - explaining the different sections of the /api/diag JSON.\n\n\nREST /debug/pprof\n\n\ncbft supports the standard \"pprof / expvars\" diagnostics of golang\nsystems, allowing users to retrieve details on goroutines, threads,\nheap memory usage and more.\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Diagnosing issues"
        }, 
        {
            "location": "/admin-guide/diagnosing/#diagnosing-issues", 
            "text": "cbft includes several REST API endpoints to programatically gather\nstats, counters and health information as JSON responses.", 
            "title": "Diagnosing issues"
        }, 
        {
            "location": "/admin-guide/diagnosing/#rest-apidiag", 
            "text": "A key REST API endpoint, however, is  /api/diag , which will\ngather as much diagnosis information as possible about a cbft node to\nbe sent in a single JSON response.  For example, for a three node cluster, you could capture the /api/diag  output of each node with something like:  curl http://cbft-01:8095/api/diag   cbft-01.json\ncurl http://cbft-02:8095/api/diag   cbft-02.json\ncurl http://cbft-03:8095/api/diag   cbft-03.json  The  /api/diag  response can be a quite large JSON object (100's\nof KB and often much more).  The motivation with  /api/diag  is to simplify working with the\nCouchbase community, forums, technical support and other engineers by\nmaking data capture from each cbft node easy in one shot.  TBD - explaining the different sections of the /api/diag JSON.", 
            "title": "REST /api/diag"
        }, 
        {
            "location": "/admin-guide/diagnosing/#rest-debugpprof", 
            "text": "cbft supports the standard \"pprof / expvars\" diagnostics of golang\nsystems, allowing users to retrieve details on goroutines, threads,\nheap memory usage and more.   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "REST /debug/pprof"
        }, 
        {
            "location": "/links/", 
            "text": "More links\n\n\nGetting help\n\n\nPlease visit the \nCouchbase Forums\n with your questions.\n\n\nReporting issues\n\n\ncbft bugs and issues are tracked at \nhttp://github.com/couchbaselabs/cbft/issues\n.\n\n\nSource code\n\n\ncbft's project source code is hosted at \nhttp://github.com/couchbaselabse/cbft\n.\n\n\nLicense\n\n\ncbft is \nApache 2\n licensed.\n\n\nContributing to cbft\n\n\nPlease see the \"Contributing fixes/improvements\"\nsection in the\n\ndeveloper's README\n.\n\n\nbleve\n\n\ncbft is based on the open-source \nbleve\n\nfull-text indexing engine.\n\n\n\n\nCopyright (c) 2015 Couchbase, Inc.", 
            "title": "Links"
        }, 
        {
            "location": "/links/#more-links", 
            "text": "", 
            "title": "More links"
        }, 
        {
            "location": "/links/#getting-help", 
            "text": "Please visit the  Couchbase Forums  with your questions.", 
            "title": "Getting help"
        }, 
        {
            "location": "/links/#reporting-issues", 
            "text": "cbft bugs and issues are tracked at  http://github.com/couchbaselabs/cbft/issues .", 
            "title": "Reporting issues"
        }, 
        {
            "location": "/links/#source-code", 
            "text": "cbft's project source code is hosted at  http://github.com/couchbaselabse/cbft .", 
            "title": "Source code"
        }, 
        {
            "location": "/links/#license", 
            "text": "cbft is  Apache 2  licensed.", 
            "title": "License"
        }, 
        {
            "location": "/links/#contributing-to-cbft", 
            "text": "Please see the \"Contributing fixes/improvements\"\nsection in the developer's README .", 
            "title": "Contributing to cbft"
        }, 
        {
            "location": "/links/#bleve", 
            "text": "cbft is based on the open-source  bleve \nfull-text indexing engine.   Copyright (c) 2015 Couchbase, Inc.", 
            "title": "bleve"
        }
    ]
}